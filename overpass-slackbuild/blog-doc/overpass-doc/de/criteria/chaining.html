<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
pre { background-color:#ccffff; padding: 0.5em; counter-reset: line; }
div[type=sibling] { text-indent:1em; }
codeline::before { counter-increment: line; content: counter(line)" "; color: #99cccc; }
</style>
  <title>Verketten</title>
</head>
<body style="font-family:sans-serif; max-width:32em">

<p><a href="../index.html">Handbuch zur Overpass API</a>  </p>

<nav>
<div type="parent"><a href="../preface/index.html">Einführung</a></div>
<div type="parent"><a href="../targets/index.html">Verwendung</a></div>
<div type="parent"><a href="../full_data/index.html">Räumliche Datenauswahl</a></div>
<div type="parent"><strong><a href="index.html">Objekte Finden</a></strong></div>

<div type="sibling"><a href="nominatim.html">Alternativen</a></div>
<div type="sibling"><a href="per_tag.html">Per Tag</a></div>
<div type="sibling"><strong> Verketten</strong></div>
<div type="sibling"><a href="union.html">Und- und Oder-Verknüpfung</a></div>
<div type="sibling"><a href="lrs.html">Semikolon-Listen</a></div>
<div type="sibling"><a href="misc_criteria.html">Mehr Suchkriterien</a></div>

</nav>
<div type="parent"><a href="../counting/index.html">Objekte Zählen</a></div>
<div type="parent"><a href="../analysis/index.html">Daten Analysieren</a></div>
<div type="parent"><a href="../more_info/index.html">Anhang</a></div>

<hr />

<h1>Verketten</h1>

<p>Wie man mehrere Suchkriterien verkettet, so dass man nach Objekten relativ zu anderen Objekten suchen kann.</p>

<nav>
<h3>Inhalt</h3>

<div type="subsection"><a href="chaining.html#lateral">Indirekte Filter</a></div>
<div type="subsection"><a href="chaining.html#topdown">Benutzte Objekte</a></div>
<div type="subsection"><a href="chaining.html#difference">Differenz</a></div>
<div type="subsection"><a href="chaining.html#equality">Tags gleichen Wertes</a></div>

</nav>

<p><a name="lateral"/></p>

<h2>Indirekte Filter</h2>

<p>Beispiele für indirekte Filter haben wir bereits bei <a href="../full_data/area.html">Areas</a> und <a href="../full_data/polygon.html">Around</a> gesehen.
Es kann <a href="../preface/design.html#sequential">per Aneinanderreihung</a> auch auf Objekte Bezug genommen werden,
die gar nicht im Endergebnis enthalten sind.</p>

<p>Wir schauen uns das am Beispiel an,
<a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=50.95&amp;lon=6.95&amp;zoom=10&amp;Q=area%5Bname%3D%22K%C3%B6ln%22%5D%3B%0Anwr%5Bamenity%3Dcafe%5D%28area%29%3B%0Aout%20center%3B">alle Cafés in Köln</a> zu finden:</p>

<pre>
<codeline>area[name="Köln"];</codeline>
<codeline>nwr[amenity=cafe](area);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Zentral ist hier der Filter <code>(area)</code> in Zeile 2.
Der Filter filtert auf die Fläche oder Flächen,
die er im Set <code>_</code> vorfindet.
Er wirkt zusammen mit dem Filter <code>[amenity=cafe]</code>,
d.h. wir suchen in Zeile 2 alle Objekte,
die <em>Node</em>, <em>Way</em> oder <em>Relation</em> sind (<em>nwr</em>) und das Tag <em>amenity</em> mit Wert <em>cafe</em> tragen
und innerhalb der in <code>_</code> hinterlegten Flächen liegen.</p>

<p>Wir können also die obige Abfrage auch umformulieren und erhalten das exakt gleiche Ergebnis:
<!-- NO_QL_LINK --></p>

<pre>
<codeline>area[name="Köln"];</codeline>
<codeline>nwr[amenity=cafe](area._);</codeline>
<codeline>out center;</codeline>
</pre>

<p>und
<!-- NO_QL_LINK --></p>

<pre>
<codeline>area[name="Köln"]-&gt;._;</codeline>
<codeline>nwr[amenity=cafe](area);</codeline>
<codeline>out center;</codeline>
</pre>

<p>und
<!-- NO_QL_LINK --></p>

<pre>
<codeline>area[name="Köln"]-&gt;._;</codeline>
<codeline>nwr[amenity=cafe](area._);</codeline>
<codeline>out center;</codeline>
</pre>

<p>In allen Fällen wird die Fläche von Zeile 1 nach Zeile 2 durch das Set <code>_</code> vermittelt.
Sets werden in <a href="../preface/design.html#sets">einem Abschnitt der Einleitung</a> eingeführt.</p>

<p>Wir können auch ein Set <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=50.95&amp;lon=6.95&amp;zoom=10&amp;Q=area%5Bname%3D%22K%C3%B6ln%22%5D%2D%3E%2Eganzlangername%3B%0Anwr%5Bamenity%3Dcafe%5D%28area%2Eganzlangername%29%3B%0Aout%20center%3B">mit beliebigem Namen</a> verwenden:</p>

<pre>
<codeline>area[name="Köln"]-&gt;.ganzlangername;</codeline>
<codeline>nwr[amenity=cafe](area.ganzlangername);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Es funktioniert allerdings nicht,
wenn der Name der Sets in beiden Zeilen nicht übereinstimmt:
<!-- NO_QL_LINK --></p>

<pre>
<codeline>area[name="Köln"]-&gt;.ganzlangername;</codeline>
<codeline>nwr[amenity=cafe](area.ganzlangrname);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Nützlich werden Set-Namen dann,
wenn man mehrere Filter ansteuern möchte.
Wir können z.B. zwar nach Cafés in Münster suchen,
aber die Overpass API weiß dann nicht,
welches Münster wir meinen,
da es außer der großen Stadt auch viele kleinere Orte mit dem Namen gibt
und diese <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=50.0&amp;lon=10.0&amp;zoom=4&amp;Q=area%5Bname%3D%22M%C3%BCnster%22%5D%3B%0Anwr%5Bamenity%3Dcafe%5D%28area%29%3B%0Aout%20center%3B">auch Cafés haben</a>:</p>

<pre>
<codeline>area[name="Münster"];</codeline>
<codeline>nwr[amenity=cafe](area);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Wir können aber verlangen,
dass das Café sowohl in Münster als auch in Nordrhein-Westfalen <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=52.0&amp;lon=7.5&amp;zoom=6&amp;Q=area%5Bname%3D%22Nordrhein%2DWestfalen%22%5D%2D%3E%2Ea%3B%0Aarea%5Bname%3D%22M%C3%BCnster%22%5D%2D%3E%2Eb%3B%0Anwr%5Bamenity%3Dcafe%5D%28area%2Ea%29%28area%2Eb%29%3B%0Aout%20center%3B">liegen muss</a>:</p>

<pre>
<codeline>area[name="Nordrhein-Westfalen"]-&gt;.a;</codeline>
<codeline>area[name="Münster"]-&gt;.b;</codeline>
<codeline>nwr[amenity=cafe](area.a)(area.b);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Die Cafés werden in Zeile 3 selektiert:
Wir wählen Objekte vom Typ <em>Node</em>, <em>Way</em> oder <em>Relation</em>,
die das Tag <code>amenity=cafe</code> tragen
und die sowohl in einer der in <code>a</code> gespeicherten Flächen (nur 1 Fläche, nämlich das Bundesland <em>Nordrhein-Westfalen</em>)
als auch in einer der in <code>b</code> gespeicherten Flächen (alle Städte, Stadtteile und Dörfer mit Namen <em>Münster</em>) liegen.
Das sind nur nur noch die Cafés in Münster in Westfalen.</p>

<p>Das Zusammenspiel zwischen mehreren Filtern und Verkettung wird <a href="union.html#full">im nächsten Abschnitt</a> vertieft.</p>

<p>Der Vollständigkeit halber sei darauf hingewiesen,
dass das Prinzip der indirekten Filter für alle Typen existiert.
Wir wollen alle Brücken über den Fluss <em>Alster</em> finden.</p>

<p>Den Fluss Alster können wir gleich auf zwei verschiedene Weisen finden,
zunächst <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=53.65&amp;lon=10.1&amp;zoom=10&amp;Q=way%5Bname%3D%22Alster%22%5D%5Bwaterway%3Driver%5D%3B%0Aout%20geom%3B">per Way</a>:</p>

<pre>
<codeline>way[name="Alster"][waterway=river];</codeline>
<codeline>out geom;</codeline>
</pre>

<p>Wir suchen dazu nach alle Objekten vom Typ <em>Way</em>,
die das Tag <em>name</em> mit Wert <em>Alster</em> und das Tag <em>waterway</em> mit Wert <em>river</em> tragen.
Diese stehen nach Zeile 1 im Set <code>_</code> und werden von dort in Zeile 2 ausgegeben.</p>

<p>Die Brücken anstatt des Flusses finden wir <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=53.65&amp;lon=10.1&amp;zoom=10&amp;Q=way%5Bname%3D%22Alster%22%5D%5Bwaterway%3Driver%5D%3B%0Away%28around%3A0%29%5Bbridge%3Dyes%5D%3B%0Aout%20geom%3B">wie folgt</a>:</p>

<pre>
<codeline>way[name="Alster"][waterway=river];</codeline>
<codeline>way(around:0)[bridge=yes];</codeline>
<codeline>out geom;</codeline>
</pre>

<p>Hier ist <code>(around:0)</code> in Zeile 2 der indirekte Filter.
Wir suchen in Zeile 2 alle <em>Ways</em>,
die das Tag <em>bridge</em> mit Wert <em>yes</em> haben
und die einen Abstand 0 zu den Objekten aus dem Set <code>_</code> haben.
Das Set <code>_</code> haben wir dazu in Zeile 1 mit den Ways befüllt, in deren Umkreis wir suchen wollen,
und zwar alle <em>Ways</em>, die ein Tag <code>name</code> mit Wert <code>Alster</code> und ein Tag <code>waterway</code> mit Wert <code>river</code> haben.</p>

<p>Das ganze funktioniert auch <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=53.65&amp;lon=10.1&amp;zoom=10&amp;Q=relation%5Bname%3D%22Alster%22%5D%5Bwaterway%3Driver%5D%3B%0Aout%20geom%3B">mit Relations</a> ...</p>

<pre>
<codeline>relation[name="Alster"][waterway=river];</codeline>
<codeline>out geom;</codeline>
</pre>

<p>... nun <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=53.65&amp;lon=10.1&amp;zoom=10&amp;Q=relation%5Bname%3D%22Alster%22%5D%5Bwaterway%3Driver%5D%3B%0Away%28around%3A0%29%5Bbridge%3Dyes%5D%3B%0Aout%20geom%3B">mit Brücken</a>:</p>

<pre>
<codeline>relation[name="Alster"][waterway=river];</codeline>
<codeline>way(around:0)[bridge=yes];</codeline>
<codeline>out geom;</codeline>
</pre>

<p><a name="topdown"/></p>

<h2>Benutzte Objekte</h2>

<p>Einer völlig anderen Anwendung für Verkettung sind wir in Abschnitten <a href="../full_data/osm_types.html#rels">Relationen</a> und <a href="../full_data/osm_types.html#rels_on_rels">Relationen auf Relationen</a> in <a href="../full_data/osm_types.html">Geometrien</a> begegnet:
Da das traditionelle OSM-Datenmodell Koordinaten nur auf <em>Nodes</em> zulässt,
aber auch an den anderen Objekten ihre Geometrie interessant ist,
müssen im traditionellen OSM-Datenmodell <em>Ways</em> und <em>Relations</em> um die jeweiligen Hilfsobjekte ergänzt werden.</p>

<p>Die Verkettungsaspekte erklären wir an einem Beispiel:
Die U-Bahn-Linie <em>Waterloo &amp; City</em> in London können wir zwar <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=14&amp;Q=rel%5Bref%3D%22Waterloo%20%26%20City%22%5D%3B%0Aout%20geom%3B">wie folgt</a> bekommen:</p>

<pre>
<codeline>rel[ref="Waterloo &amp; City"];</codeline>
<codeline>out geom;</codeline>
</pre>

<p>Dann gebrauchen wir aber ein <a href="../targets/formats.html#extras">erweitertes Datenmodell</a>,
das nicht alle Anwendungen unterstützen.
Wenn wir dagegen den traditionellen Detailgrad <em>out</em> <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=14&amp;Q=rel%5Bref%3D%22Waterloo%20%26%20City%22%5D%3B%0Aout%3B">zur Ausgabe nutzen</a>,
so sehen wir gar nichts:</p>

<pre>
<codeline>rel[ref="Waterloo &amp; City"];</codeline>
<codeline>out;</codeline>
</pre>

<p>Die Relation steht nach der Ausgabe in Zeile 2 aber noch immer im Set <code>_</code>.
Wir können daher die zugehörigen <em>Ways</em> und <em>Nodes</em> sammeln,
indem wir das im <a href="union.html#union">folgenden Abschnitt</a> erläuterte <em>Union</em> mit Verkettung <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=14&amp;Q=rel%5Bref%3D%22Waterloo%20%26%20City%22%5D%3B%0Aout%3B%0A%28%0A%20%20way%28r%29%3B%0A%20%20node%28w%29%3B%0A%29%3B%0Aout%20skel%3B">kombinieren</a>:</p>

<pre>
<codeline>rel[ref="Waterloo &amp; City"];</codeline>
<codeline>out;</codeline>
<codeline>(</codeline>
<codeline>  way(r);</codeline>
<codeline>  node(w);</codeline>
<codeline>);</codeline>
<codeline>out skel;</codeline>
</pre>

<p>Vor Zeile 3 stehen im Set <code>_</code> wie schon erwähnt die gefundenen Relationen.
Zeilen 3 bis 6 sind das <a href="union.html#union">Union</a>.
Zeile 4 <code>way(r)</code> ist daher die nächste nach Zeile 2 ausgeführte Zeile und erhält die Relationen als Eingabe.
Es sucht nach <em>Ways</em>, die dem Filter <code>(r)</code> genügen,
d.h. von einer oder mehreren <em>Relations</em> in der Eingabe referenziert werden.
Als Ergebnis schreibt es diese Ways nun in das Set <code>_</code>.
Das Block-Statement <em>Union</em> behält gemäß seiner Semantik eine Kopie davon für sein Ergebnis.</p>

<p>Zeile 5 <code>node(w)</code> findet also die Ways aus Zeile 4 als Eingabe im Set <code>_</code> vor.
Es sucht nach <em>Nodes</em>, die dem Filter <code>(w)</code> genügen,
d.h. von einer oder mehreren <em>Ways</em> in der Eingabe referenziert werden.
Als Ergebnis schreibt es diese Ways zwar in das Set <code>_</code>,
aber <em>Union</em> ersetzt das Set ohnehin durch sein eigenes Ergebnis.</p>

<p>Als Ergebnis von Zeile 6 schreibt <em>Union</em> in das Set <code>_</code> die Vereinigung der Ergebnisse,
die es gesehen hat.
Wir erhalten also alle <em>Ways</em>, die von den Relationen referenziert worden sind
und alle <em>Nodes</em>, die von diesen <em>Ways</em> referenziert worden sind.</p>

<p>Allerdings können Relationen auch <em>Nodes</em> direkt als Member haben,
und diese Relationen haben dies auch;
man sieht dies im <a href="../targets/turbo.html#basics">Daten</a>-Tab oder <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=14&amp;Q=rel%5Bref%3D%22Waterloo%20%26%20City%22%5D%3B%0Anode%28r%29%3B%0Aout%3B">per Abfrage</a>:</p>

<pre>
<codeline>rel[ref="Waterloo &amp; City"];</codeline>
<codeline>node(r);</codeline>
<codeline>out;</codeline>
</pre>

<p>Auf diesem Weg ersetzen wir im Set <code>_</code> in Zeile 2 die <em>Relations</em> durch die referenzierten <em>Nodes</em>.
Dann haben wir zwar für die Ausgabe in Zeile 3 diese Nodes zur Verfügung,
bräuchten aber die <em>Relations</em> erneut,
um die referenzierten <em>Ways</em> zu erhalten.
Können wir die Doppelsuche vermeiden?</p>

<p>Ja, <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=14&amp;Q=rel%5Bref%3D%22Waterloo%20%26%20City%22%5D%3B%0Aout%3B%0A%28%0A%20%20node%28r%29%2D%3E%2Edirekt%5Fvon%5Fden%5Frelations%5Freferenziert%3B%0A%20%20way%28r%29%3B%0A%20%20node%28w%29%3B%0A%29%3B%0Aout%20skel%3B">mit benannten Sets</a>:</p>

<pre>
<codeline>rel[ref="Waterloo &amp; City"];</codeline>
<codeline>out;</codeline>
<codeline>(</codeline>
<codeline>  node(r)-&gt;.direkt_von_den_relations_referenziert;</codeline>
<codeline>  way(r);</codeline>
<codeline>  node(w);</codeline>
<codeline>);</codeline>
<codeline>out skel;</codeline>
</pre>

<p>Im Detail:</p>

<ul>
<li>Nach Zeile 1 stehen im Set <code>_</code> alle <em>Relations</em>,
die ein Tag <code>ref</code> mit Wert <code>Waterloo &amp; City</code> haben.</li>
<li>In Zeile 2 werden diese ausgegeben.
Im Set <code>_</code> stehen nach wie vor die <em>Relations</em>.</li>
<li>Das Block-Statement <em>Union</em> von Zeile 3 bis Zeile 7 führt den Block in seinem Inneren aus.</li>
<li>In Zeile 4 wird daher von <code>(r)</code> der Inhalt von Set <code>_</code> genutzt, nämlich die <em>Relations</em> aus Zeile 1.
Damit werden neu im Set <code>direkt_von_den_relations_referenziert</code> diejenigen <em>Nodes</em> abgelegt,
die von einer der <em>Relations</em> referenziert werden.
<em>Union</em> behält eine Kopie des Ergebnisses zurück.
Ansonsten sind wir nicht an dem Ergebnis interessiert,
sondern wollen nur das Statement davon abhalten, das Set <code>_</code> zu überschreiben.</li>
<li>In Zeile 5 wird von <code>(r)</code> wiederum der Inhalt von Set <code>_</code> genutzt,
und dies sind noch immer die <em>Relations</em>, da wir diese nicht überschrieben haben.
Im Set <code>_</code> sind nun die <em>Ways</em> abgelegt, die von den <em>Relations</em> referenziert werden.
<em>Union</em> behält eine Kopie des Ergebnisses zurück.</li>
<li>In Zeile 6 wird von <code>(w)</code> wiederum der Inhalt von Set <code>_</code> genutzt.
Dies sind nun die in Zeile 5 geschriebenen <em>Ways</em>.
Also werden im Set <code>_</code> nun die von diesen <em>Ways</em> referenzierten <em>Nodes</em> abgelegt.
<em>Union</em> behält eine Kopie des Ergebnisses zurück.</li>
<li><em>Union</em> setzt nun aus seinen Teilergebnisse der Zeilen 4, 5 und 6 das Gesamtergebnis zusammen
und schreibt es in das Set <code>_</code>.</li>
<li>In Zeile 8 wird nun das Set <code>_</code> ausgegeben.</li>
</ul>

<p>Da dies ein sehr häufiges Problem ist,
gibt es für genau diese Aufgabe auch <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=14&amp;Q=rel%5Bref%3D%22Waterloo%20%26%20City%22%5D%3B%0Aout%3B%0A%3E%3B%0Aout%20skel%3B">eine Abkürzung</a>:</p>

<pre>
<codeline>rel[ref="Waterloo &amp; City"];</codeline>
<codeline>out;</codeline>
<codeline>&gt;;</codeline>
<codeline>out skel;</codeline>
</pre>

<p>Zeilen 1 und 2 arbeiten exakt wie vorher,
und Zeile 4 arbeitet exakt wie Zeile 8 vorher:
Denn der Pfeil in Zeile 3 hat als Semantik,
dass er zu Relations im Set <code>_</code> die direkt und indirekt referenzierten <em>Ways</em> und <em>Nodes</em> findet
und ins Set <code>_</code> ausgibt.</p>

<p>Nun sind zuletzt noch einige Programme überfordert,
wenn die Reihenfolge in der Datei nicht exakt alle <em>Nodes</em>, dann alle <em>Ways</em>, dann zuletzt alle <em>Relations</em> ist.</p>

<p>Für den detaillierten Ansatz erreicht man dies,
indem die initiale Anfrage in den <em>Union</em>-Block <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=14&amp;Q=%28%0A%20%20rel%5Bref%3D%22Waterloo%20%26%20City%22%5D%3B%0A%20%20node%28r%29%2D%3E%2Edirekt%5Fvon%5Fden%5Frelations%5Freferenziert%3B%0A%20%20way%28r%29%3B%0A%20%20node%28w%29%3B%0A%29%3B%0Aout%3B">verschiebt</a>:</p>

<pre>
<codeline>(</codeline>
<codeline>  rel[ref="Waterloo &amp; City"];</codeline>
<codeline>  node(r)-&gt;.direkt_von_den_relations_referenziert;</codeline>
<codeline>  way(r);</codeline>
<codeline>  node(w);</codeline>
<codeline>);</codeline>
<codeline>out;</codeline>
</pre>

<p>Ebenso <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=14&amp;Q=%28%0A%20%20rel%5Bref%3D%22Waterloo%20%26%20City%22%5D%3B%0A%20%20%3E%3B%0A%29%3B%0Aout%3B">mit dem Pfeil</a>:</p>

<pre>
<codeline>(</codeline>
<codeline>  rel[ref="Waterloo &amp; City"];</codeline>
<codeline>  &gt;;</codeline>
<codeline>);</codeline>
<codeline>out;</codeline>
</pre>

<p><a name="difference"/></p>

<h2>Differenz</h2>

<p>...
<!--
  TODO: Differenz wegen ._-Falle
--></p>

<p><a name="equality"/></p>

<h2>Tags gleichen Wertes</h2>

<p>...
<!--
  TODO: Wertgleichheit via Evaluator</p>

<p>Indoor
  doppelte Hausnummern
  name vs name:XX
--></p>
<hr/>
<p>weiter: <a href="union.html">Und- und Oder-Verknüpfung</a></p>

</body>
</html>
