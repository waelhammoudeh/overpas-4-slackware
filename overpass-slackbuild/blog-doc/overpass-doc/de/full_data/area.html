<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
pre { background-color:#ccffff; padding: 0.5em; counter-reset: line; }
div[type=sibling] { text-indent:1em; }
codeline::before { counter-increment: line; content: counter(line)" "; color: #99cccc; }
</style>
  <title>Suche per Area</title>
</head>
<body style="font-family:sans-serif; max-width:32em">

<p><a href="../index.html">Handbuch zur Overpass API</a>  </p>

<nav>
<div type="parent"><a href="../preface/index.html">Einführung</a></div>
<div type="parent"><a href="../targets/index.html">Verwendung</a></div>
<div type="parent"><strong><a href="index.html">Räumliche Datenauswahl</a></strong></div>

<div type="sibling"><a href="bbox.html">Bounding-Boxen</a></div>
<div type="sibling"><a href="osm_types.html">Geometrien</a></div>
<div type="sibling"><a href="map_apis.html">Weitere Map-APIs</a></div>
<div type="sibling"><a href="polygon.html">Polygon und Around</a></div>
<div type="sibling"><strong> Suche per Area</strong></div>
<div type="sibling"><a href="other_sources.html">Alternativen</a></div>

</nav>
<div type="parent"><a href="../criteria/index.html">Objekte Finden</a></div>
<div type="parent"><a href="../counting/index.html">Objekte Zählen</a></div>
<div type="parent"><a href="../analysis/index.html">Daten Analysieren</a></div>
<div type="parent"><a href="../more_info/index.html">Anhang</a></div>

<hr />

<h1>Suche per Area</h1>

<p>Alle Daten in einem benannten Gebiet wie z.B. einer Stadt oder einem Bundesland.</p>

<nav>
<h3>Inhalt</h3>

<div type="subsection"><a href="area.html#deprecation">Warnung zur Zukunft</a></div>
<div type="subsection"><a href="area.html#per_tag">Per Name oder per Tag</a></div>
<div type="subsection"><a href="area.html#full">Wirklich Alles</a></div>
<div type="subsection"><a href="area.html#combining">Fläche-in-Fläche</a></div>
<div type="subsection"><a href="area.html#background">Technischer Hintergrund</a></div>

</nav>

<p><a name="deprecation"/></p>

<h2>Warnung zur Zukunft</h2>

<p>Der Anspruch an die Inhalte dieses Handbuchs ist,
dass sie auch in vielen Jahren noch zutreffen.
Für das derzeitige <em>Area</em>-Konzept gilt dies nicht unbedingt:
Der Datentyp ist entstanden, um kompatibel bleiben zu können,
falls im OpenStreetMap-Datenmodell ein Datentyp für Flächen dazukommt.
Mittlerweile bin ich sehr sicher, dass dies nicht mehr passieren wird.</p>

<p>Daher plane ich nun,
Flächen direkt ab den etablierten Typen <em>geschlossener Way</em> und <em>Relations</em> anzubieten.
Die konkrete Planung und Umsetzung wird sicherlich eher Jahre in Anspruch nehmen.
Am Ende diese Prozesses werden aber einige der hier aufgeführten Syntax-Varianten wohl veraltet sein.
Im Rahmen der <a href="../preface/assertions.html#infrastructure">Rückwärtskompatibilität</a> werden möglichst wenige Abfragen für veraltet erklärt.</p>

<p>Derzeit ist beabsichtigt,
dass <em>area</em> dann als Synonym für <em>Way</em> plus <em>Relation</em> plus einen Evaluator <code>is_closed()</code> verwendet wird.
Umgekehrt wird <code>is_in</code> dann wohl ebendiese Datentypen finden;
es wird sich anbieten, dieses <em>Statement</em> dabei durch einen Filter abzulösen.</p>

<p>Umgekehrt bitte ich Sie, dies nicht als eine konkrete Ankündigung misszuverstehen.
Es gibt andere Anliegen im Projekt mit größerem Leidensdruck.</p>

<p><a name="per_tag"/></p>

<h2>Per Name oder per Tag</h2>

<p>Der typische Einsatzfall für Flächen in der Overpass API ist,
alle Objekte von einem Typ oder alle Objekte generell in einem Gebiet herunterzuladen.
Wir fangen mit allen Objekten von einem mäßig häufigen Typ an;
alle Objekte generell sind zu viele Daten,
um mit kurzen Reaktionszeiten üben zu können.
Wenn der <em>Area</em>-Mechanismus in diesem Abschnitt eingeführt ist,
folgt der Download aller Objekte im <a href="area.html#full">folgenden Abschnitt</a>.</p>

<p>Wir wollen zunächst <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=30.0&amp;lon=0.0&amp;zoom=2&amp;Q=area%5Bname%3D%22London%22%5D%3B%0Anwr%5Bshop%3Dsupermarket%5D%28area%29%3B%0Aout%20center%3B">alle Supermärkte in London</a> anzeigen:</p>

<pre>
<codeline>area[name="London"];</codeline>
<codeline>nwr[shop=supermarket](area);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Die eigentliche Arbeit wird in Zeile 2 geleistet:
dort beschränkt der <em>Filter</em> <code>(area)</code> die zu selektierenden Objekte
auf solche nur in den Flächen aus dem Set <code>_</code>;
wir müssen also vorher die <em>Area</em> zu London geliefert haben.</p>

<p>Zeile 1 selektiert alle Objekte vom Typ <em>Area</em>,
die ein Tag mit Key <code>name</code> und Wert <code>London</code> besitzen.
Dieser Objekttyp wird <a href="area.html#background">unten</a> erläutert.
Es handelt sich im übrigen um ein spezielles <a href="../preface/design.html#statements">Query-Statement</a>.</p>

<p>Überraschenderweise verteilen sich die Fundstellen über den halben Planeten.
Es gibt eben viele Flächen namens London;
wir müssen ausdrücken, dass uns das große London in England interessiert.
Uns stehen gleich fünf verschiedene Lösungswege zur Verfügung,
unsere Anfrage zu präzisieren.</p>

<p>Wir können eine große Bounding-Box um die ungefähre Zielregion <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=30.0&amp;lon=0.0&amp;zoom=2&amp;Q=area%5Bname%3D%22London%22%5D%3B%0Anwr%5Bshop%3Dsupermarket%5D%28area%29%2850%2E5%2C%2D1%2C52%2E5%2C1%29%3B%0Aout%20center%3B">legen und nutzen</a>:</p>

<pre>
<codeline>area[name="London"];</codeline>
<codeline>nwr[shop=supermarket](area)(50.5,-1,52.5,1);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Für Ihre Bequemlichkeit sei darauf hingewiesen, dass dies auch mit dem <a href="../targets/turbo.html#convenience">Komfortfeature</a> von <em>Overpass Turbo</em> <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=10&amp;Q=area%5Bname%3D%22London%22%5D%3B%0Anwr%5Bshop%3Dsupermarket%5D%28area%29%28%7B%7Bbbox%7D%7D%29%3B%0Aout%20center%3B">geht</a>:</p>

<pre>
<codeline>area[name="London"];</codeline>
<codeline>nwr[shop=supermarket](area)({{bbox}});</codeline>
<codeline>out center;</codeline>
</pre>

<p>In beiden Fällen ist die Bounding-Box ein Filter parallel zu <code>(area)</code>.
Für das Provisorium <em>Area</em> ist niemals eine Bounding-Box implementiert worden,
auch deswegen, da es reicht,
den Filter eine Anweisung später anzuwenden.</p>

<p>In ähnlicher Weise können wir auch ausnutzen, dass London in Großbritannien liegt.
Ein <a href="area.html#combining">späterer Abschnitt</a> zeigt alle Möglichkeiten dazu auf.</p>

<p>Nicht zuletzt kann man auch weitere Tags zur Unterscheidung der <em>Areas</em> mit gleichem <em>name</em>-Tag heranziehen.
Im Falle von London <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=30.0&amp;lon=0.0&amp;zoom=2&amp;Q=area%5Bname%3D%22London%22%5D%5B%22wikipedia%22%3D%22en%3ALondon%22%5D%3B%0Anwr%5Bshop%3Dsupermarket%5D%28area%29%3B%0Aout%20center%3B">hilft das Tag</a> zum Key <em>wikipedia</em>:</p>

<pre>
<codeline>area[name="London"]["wikipedia"="en:London"];</codeline>
<codeline>nwr[shop=supermarket](area);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Wie bereits der erste Filter nach Tag <code>[name="London"]</code>
wird auch der zweite Filter <code>["wikipedia"="en:London"]</code> auf die <em>Area</em>-Query in Zeile 1 angewendet.
Dadurch bleibt diesmal nur das eine <em>Area</em>-Objekt übrig,
in dem wir tatsächlich suchen wollen.</p>

<p>Andere häufig nützliche Filter können <code>admin_level</code> mit oder ohne Wert oder <code>type=boundary</code> sein.
Es hilft dazu, sich zunächst alle gefundenen <em>Area</em>-Objekte <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=10&amp;Q=area%5Bname%3D%22London%22%5D%3B%0Aout%3B">anzeigen zu lassen</a>;
bitte nach dem Ausführen per <em>Daten</em> oben rechts auf die Daten-Ansicht umschalten:</p>

<pre>
<codeline>area[name="London"];</codeline>
<codeline>out;</codeline>
</pre>

<p>Zeile 2 gibt aus, was Zeile 1 findet.
Bitte sichten Sie die Funde danach, welche <em>Tags</em> die richtige Fläche selektieren.
Mittels <em>pivot</em>-Filter in einem Query-Statement können Sie diese auch <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=30.0&amp;lon=0.0&amp;zoom=2&amp;Q=area%5Bname%3D%22London%22%5D%3B%0Anwr%28pivot%29%3B%0Aout%20geom%3B">visualisieren</a>:</p>

<pre>
<codeline>area[name="London"];</codeline>
<codeline>nwr(pivot);</codeline>
<codeline>out geom;</codeline>
</pre>

<p>In Zeile 2 steht dabei ein reguläres Query-Statement.
Der <em>Filter</em> <code>(pivot)</code> darin lässt genau diejenigen Objekte zu,
die die Erzeuger der in seiner Eingabe befindlichen <em>Areas</em> sind.
Das ist das Set <code>_</code>;
es ist in Zeile 1 befüllt worden.</p>

<p>Als fünfte Möglichkeit gibt es ein Komfort-Feature von <a href="../targets/turbo.html">Overpass Turbo</a>,
um Nominatim <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=10&amp;Q=%7B%7BgeocodeArea%3ALondon%7D%7D%3B%0Anwr%5Bshop%3Dsupermarket%5D%28area%29%3B%0Aout%20center%3B">auswählen zu lassen</a>:</p>

<pre>
<codeline>{{geocodeArea:London}};</codeline>
<codeline>nwr[shop=supermarket](area);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Dabei löst der Ausdruck <code>{{geocodeArea:London}}</code> aus,
dass <em>Overpass Turbo</em> bei <em>Nominatim</em> erfragt, was das plausibelste Objekt zu <code>London</code> ist.
Mittels der von Nominatim zurückgelieferten Id
ersetzt Overpass Turbo den Ausdruck durch eine Id-Query nach der zugehörigen Fläche,
hier z.B. <code>area(3600065606)</code>.</p>

<p><a name="full"/></p>

<h2>Wirklich Alles</h2>

<!-- TODO: Timeout auf Curl und Wget -->

<p>Wir wollen nun wirklich alle Daten in einem Gebiet herunterladen.
Das geht zwar mit fast der Abfrage, die wir <a href="area.html#per_tag">zum Üben</a> verwendet haben.
Aber wir müssen das Werkzeug wechseln:
für ein Gebiet von der Größe Londons kommen schnell 10 Mio. Objekte oder mehr zusammen,
während <em>Overpass Turbo</em> bereits ab etwa 2000 Objekten den Browser bis zur Unbrauchbarkeit verlangsamt.</p>

<p>Zudem sind Sie bei fast allen Gebieten in offiziellen Grenzen von Staaten bis Städten besser bedient mit regionalen Extrakten.
Details dazu <a href="other_sources.html#regional">im dazugehörigen Abschnitt</a>.</p>

<p>Sie können die Rohdaten zur Weiterverarbeitung direkt auf ihren lokalen Rechner herunterladen:
Dazu dient in <em>Overpass Turbo</em> unter <em>Export</em> oben links der Link <code>Rohdaten direkt von der Overpass API</code>.
Es ist normal, dass nach de Klick erst einmal nichts passiert.
London herunterzuladen kann mehrere Minuten dauern.</p>

<p>Alternativ sei auf Download-Werkzeuge wie <a target="_blank" rel="noopener" href="https://www.gnu.org/software/wget/">Wget</a> oder <a target="_blank" rel="noopener" href="https://curl.haxx.se/">Curl</a> verwiesen.
Um das zu üben, speichern Sie bitte eine der Abfragen von oben in eine lokale Datei, z.B. <code>london.ql</code>.</p>

<p>Sie können dann Abfragen ab der Kommandozeile stellen mit
<!-- NO_QL_LINK --></p>

<pre>
<codeline>wget -O london.osm.gz --header='Accept-Encoding: gzip, deflate' \</codeline>
<codeline>    --post-file=london.ql 'https://overpass-api.de/api/interpreter'</codeline>
</pre>

<p>bzw.
<!-- NO_QL_LINK --></p>

<pre>
<codeline>curl -H'Accept-Encoding: gzip, deflate' -d@- \</codeline>
<codeline>    'https://overpass-api.de/api/interpreter' \</codeline>
<codeline>    &lt;london.ql &gt;london.osm.gz</codeline>
</pre>

<p>Beide Anweisungen können natürlich ohne den Rückstrich auch in je einer Zeile geschrieben werden.
In beiden Fällen tuen Sie mir, sich und allen übrigen Benutzern einen großen Gefallen,
wenn Sie den zusätzlichen Header <code>Accept-Encoding: gzip, deflate</code> setzen.
Dies gestattet dem Server, die Daten zu komprimieren,
was die Datenmengen um ca. den Faktor 7 verkleinert
und beide Enden der Verbindung entlastet.</p>

<p>Nun kommen wir zu der eigentlichen Abfrage.
Da eine Quelle großer Datenmengen bei vollen Daten räumliche ausgedehnte Relationen sind,
gibt es an den endgültigen Anwendungszweck <a href="osm_types.html">angepasste Varianten</a>.
Wir beschränken uns hier zunächst auf eine häufig passende Variante:
<!-- NO_QL_LINK --></p>

<pre>
<codeline>area[name="London"]["wikipedia"="en:London"];</codeline>
<codeline>(</codeline>
<codeline>  nwr(area);</codeline>
<codeline>  node(w);</codeline>
<codeline>);</codeline>
<codeline>out;</codeline>
</pre>

<p>Alternativ sei noch eine Variante mit mehrfacher Nutzung des <em>Area</em>-Filters genannt.
Dann sollten die als Eingabe selektierten Areas in einer <em>benannten Set-Variable</em> <a href="../preface/design.html#sets">zwischengespeichert</a> werden:
<!-- NO_QL_LINK --></p>

<pre>
<codeline>area[name="London"]["wikipedia"="en:London"]-&gt;.suchgebiet;</codeline>
<codeline>(</codeline>
<codeline>  node(area.suchgebiet);</codeline>
<codeline>  way(area.suchgebiet);</codeline>
<codeline>  node(w);</codeline>
<codeline>);</codeline>
<codeline>out;</codeline>
</pre>

<p>Hier schreibt in Zeile 3 das Query-Statement in die Standard-Auswahl.
Da die <em>Area</em>-Auswahl in Zeile 4 aber noch als Eingabe benötigt wird,
muss sie an einem anderen Ort als der Standard-Auswahl liegen.</p>

<p><a name="combining"/></p>

<h2>Fläche-in-Fläche</h2>

<p>Wir kommen zurück zu dem Problem,
London als Fläche in Großbritannien auszuwählen.
Das ist nicht implementiert,
aber es gibt auch hier wieder zwei andere Möglichkeiten.</p>

<p>Man kann Objekte suchen, die <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=8&amp;Q=area%5Bname%3D%22London%22%5D%2D%3E%2Eklein%3B%0Aarea%5Bname%3D%22England%22%5D%2D%3E%2Egrosz%3B%0Anwr%5Bshop%3Dsupermarket%5D%28area%2Eklein%29%28area%2Egrosz%29%3B%0Aout%20center%3B">in der Schnittmenge zweier Flächen</a> liegen:</p>

<pre>
<codeline>area[name="London"]-&gt;.klein;</codeline>
<codeline>area[name="England"]-&gt;.grosz;</codeline>
<codeline>nwr[shop=supermarket](area.klein)(area.grosz);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Das eigentliche Filtern findet im Query-Statement in Zeile 3 statt;
dort werden nur Objekte zugelassen, die alle drei Filter erfüllen:
Der Filter <code>[shop=supermarket]</code> lässt nur Objekte mit dem entsprechenden Tag zu.
Der Filter <code>(area.klein)</code> beschränkt dies auf Objekte,
die innerhalb einer der in <code>klein</code> befindlichen Flächen liegen.
Der Filter <code>(area.grosz)</code> reduziert dies weiter auf Objekte,
die innerhalb einer der in <code>grosz</code> befindlichen Flächen liegen.</p>

<p>Nun müssen wir nur noch sicherstellen,
dass in <code>klein</code> bzw. <code>grosz</code> die gewollten Flächen drinstehen.
Die erledigen jeweils Query-Statements nach <em>Areas</em> in den Zeilen 1 und 2,
die ihr Ergebnis in eine benannte Variable speichern.</p>

<p>Das andere Vorgehen verwendet den Zusammenhang zwischen <em>Area</em> und dem erzeugenden Objekt,
allerdings diesmal in die dem Filter <em>pivot</em> entgegengesetzte Richtung.
Wir <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=8&amp;Q=area%5Bname%3D%22England%22%5D%3B%0Arel%5Bname%3D%22London%22%5D%28area%29%3B%0Amap%5Fto%5Farea%3B%0Anwr%5Bshop%3Dsupermarket%5D%28area%29%3B%0Aout%20center%3B">selektieren</a> das erzeugte Objekt der kleinen Fläche:</p>

<pre>
<codeline>area[name="England"];</codeline>
<codeline>rel[name="London"](area);</codeline>
<codeline>map_to_area;</codeline>
<codeline>nwr[shop=supermarket](area);</codeline>
<codeline>out center;</codeline>
</pre>

<p>In Zeile 4 wollen wir für den Filter <code>(area)</code> exakt die <em>Area</em> zu London als Eingabe haben.
Dazu selektieren wir in Zeile 2 alle <em>Relations</em>, die den Namen <em>London</em> haben
und innerhalb einer der Flächen liegen,
die <code>(area)</code> in der EIngabe im Default-Set <code>_</code> vorfindet.
Für diese hatten wir in Zeile 1 alle Flächen mit Name <em>England</em> ausgewählt.</p>

<p>Nun brauchen wir aber in Zeile 4 ja Flächen,
während der Filter <code>(area)</code> keine Flächen filtern kann und wir daher <em>Relations</em> selektiert haben.
Dies erledigt <code>map_to_area</code>:
es ordnet den Objekten aus seiner Eingabe die von den Objekten erzeugten Flächen zu.</p>

<p><a name="background"/></p>

<h2>Technischer Hintergrund</h2>

<p>Bereits am Anfang des Overpass-Projekts im Jahr 2009 sollte es die Möglichkeit geben,
ein geometrisches A-liegt-in-B nutzen zu können.
Das hat sich nur denkbar schlecht mit der Anforderung vertragen,
<a href="../preface/assertions.html#faithful">OpenStreetMap-Daten treu abzubilden</a>:
Flächen sind in OpenStreetMap ein gemischtes Konzept aus Geometrie und Tags,
es gab glaubwürdige Bestrebungen, einen eigenen Datentyp <em>Area</em> zu entwickeln,
und die Regeln dafür, wann genau ein OpenStreetMap-Objekt eine Fläche ist, sind damals noch im Fluss gewesen.
Zuletzt gab es den Eindruck, dass Flächen leicht beschädigt werden könnten und dies häufiger zu erwarten ist.</p>

<p>Daher sind <em>Areas</em> in Overpass API ein eigener Datentyp.
Der Server erzeugt diese in einem zyklischen Hintergrundprozess nach einem vom Code getrennten <a target="_blank" rel="noopener" href="https://github.com/drolbr/Overpass-API/tree/master/src/rules">Regelsatz</a>.
Damit haben es potentielle Betreiber eigener Instanzen einfacher,
selbst zu entscheiden, welche Flächen sie erzeugen wollen.
Jede <em>Area</em> übernimmt dabei bei ihrer Erzeugung die Tags des Objektes, aus dem sie erzeugt worden ist.</p>

<p>Dies zieht Folgen nach sich:</p>

<ul>
<li>Flächen stehen erst viele Stunden später zu Verfügung als ihre erzeugenden Objekte.
Entsprechend wirken sich auch Änderungen an den erzeugenden Objekten verzögert aus.</li>
<li>Ergibt ein erzeugendes Objekt keine gültige Fläche mehr,
so bleibt das alte <em>Area</em>-Objekt bestehen, bis wieder eine neue gültige Fläche erzeugt werden kann.</li>
<li>Areas haben eigene Regeln, nach denen ihre Ids vergeben werden.</li>
<li>Nur ein Teil der Filter für OpenStreetMap-Objekte steht auch für <em>Areas</em> zur Verfügung.</li>
</ul>

<p>Der große Vorteil ist aber, dass die Suche Punkt-in-Fläche effizient und zuverlässig funktioniert.</p>

<p>Als Nachteil hat sich herausgestellt, dass nicht alle nachgefragten <em>Area</em>-Objekte existieren:
mittlerweile wird fast jedes Objekt in OpenStreetMap, das von seiner Geometrie her eine Fläche ergibt,
auch als Fläche genutzt.
Wenn aber gemäßg den Tagging-Regeln der Hintergrundprozess das Objekt nicht für eine Fläche hält,
gibt es kein korrespondierendes <em>Area</em>-Objekt.</p>

<p>Umgekehrt ist mir in den letzten 10 Jahren keine Instanz begegnet,
die ihre Flächen-Regelwerk an ihre speziellen Bedürfnisse angepasst hat.
Es gab wohl eher einen Tradeoff, weniger Flächen zu akzeptieren,
um Rechenzeit beim Hintergrundprozess zu sparen.
Damit ist der Regelsatz doch de facto zentral festgelegt,
und dies beraubt ihn der meisten seiner Vorteile.</p>

<p>Daher beabsichtige ich mittlerweile,
auch die Flächenoperationen direkt auf den OpenStreetMap-Objekten auszuführen.</p>
<hr/>
<p>weiter: <a href="other_sources.html">Alternativen</a></p>

</body>
</html>
