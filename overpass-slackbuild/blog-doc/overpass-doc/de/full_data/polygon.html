<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
pre { background-color:#ccffff; padding: 0.5em; counter-reset: line; }
div[type=sibling] { text-indent:1em; }
codeline::before { counter-increment: line; content: counter(line)" "; color: #99cccc; }
</style>
  <title>Polygon und Around</title>
</head>
<body style="font-family:sans-serif; max-width:32em">

<p><a href="../index.html">Handbuch zur Overpass API</a>  </p>

<nav>
<div type="parent"><a href="../preface/index.html">Einführung</a></div>
<div type="parent"><a href="../targets/index.html">Verwendung</a></div>
<div type="parent"><strong><a href="index.html">Räumliche Datenauswahl</a></strong></div>

<div type="sibling"><a href="bbox.html">Bounding-Boxen</a></div>
<div type="sibling"><a href="osm_types.html">Geometrien</a></div>
<div type="sibling"><a href="map_apis.html">Weitere Map-APIs</a></div>
<div type="sibling"><strong> Polygon und Around</strong></div>
<div type="sibling"><a href="area.html">Suche per Area</a></div>
<div type="sibling"><a href="other_sources.html">Alternativen</a></div>

</nav>
<div type="parent"><a href="../criteria/index.html">Objekte Finden</a></div>
<div type="parent"><a href="../counting/index.html">Objekte Zählen</a></div>
<div type="parent"><a href="../analysis/index.html">Daten Analysieren</a></div>
<div type="parent"><a href="../more_info/index.html">Anhang</a></div>

<hr />

<h1>Polygon und Around</h1>

<p>Neben der Bounding-Box gibt es weitere, dem Zielgebiet besser anpassbare Begrenzungsrahmen.</p>

<p>Koordinaten in Breiten- und Längengrad sind zwar als Konzept gut verständlich,
aber die wenigsten Menschen kennen zu den sie interessierenden Orten die Koordinaten auswendig.</p>

<p>Es wird daher zunächst die indirekte Suche anhand von benannten Objekten vorgestellt.
Die Suche in Flächen ist dabei einerseits herausragend häufig,
hat aber andererseits mehrere Besonderheiten.
Sie wird daher in einem <a href="area.html">anderen Unterkapitel</a> behandelt.</p>

<p>Im ersten Unterkapitel geht es um die Suche im Umkreis von benannten Objekten.
Die Suche im Umkreis von Koordinaten schließt sich an.
Zuletzt werden noch Polygone als räumlicher Suchfilter vorgestellt.</p>

<nav>
<h3>Inhalt</h3>

<div type="subsection"><a href="polygon.html#around">Around-Filter ab Objekten</a></div>
<div type="subsection"><a href="polygon.html#absolute_around">Around-Filter mit Koordinaten</a></div>
<div type="subsection"><a href="polygon.html#polygon">Polygone als Begrenzung</a></div>

</nav>

<p><a name="around"/></p>

<h2>Around-Filter ab Objekten</h2>

<p>Es ist eine anspruchsvolle Aufgabe,
aus einem Text zuverlässig einen konkreten Ort zu ermitteln.
Daher fällt dies auch eigentlich einem Geocoder zu, z.B. <a href="../criteria/nominatim.html#nominatim">Nominatim</a>,
und wird hier nicht vertieft.
Mit den Ergebnissen von Nominatim kann schon die im nächsten Abschnitt beschriebene Suche um Koordinaten benutzt werden.</p>

<p>Es gibt aber genug Beispiele, bei denen bereits der Name das richtige Objekt <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.0&amp;lon=10.0&amp;zoom=6&amp;Q=nwr%5Bname%3D%22K%C3%B6lner%20Dom%22%5D%3B%0Aout%20geom%3B">liefert</a>:</p>

<pre>
<codeline>nwr[name="Kölner Dom"];</codeline>
<codeline>out geom;</codeline>
</pre>

<p>In Zeile 1 suchen wir nach allen Objekten,
die ein Tag <code>name</code> mit Wert <code>Kölner Dom</code> besitzen.
Dieses wird im Set <code>_</code> abgelegt,
und in Zeile 2 gibt <code>out geom</code> aus, was es im Set <code>_</code> vorfindet.</p>

<p>Zur Erinnerung: <a href="../targets/turbo.html#basics">Die Lupe</a> zoomt auf die Fundstellen heran.
Gerade bei indirekten Filtern ist es oft sinnvoll, die ursprüngliche Objektsuche auszuführen,
um auszuschließen, dass es weitere gleichnamige Objekte <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.0&amp;lon=10.0&amp;zoom=6&amp;Q=nwr%5Bname%3D%22Viktualienmarkt%22%5D%3B%0Aout%20geom%3B">an anderen Orten</a> gibt:</p>

<pre>
<codeline>nwr[name="Viktualienmarkt"];</codeline>
<codeline>out geom;</codeline>
</pre>

<p>Eine <a href="bbox.html#filter">Bounding-Box</a> oder die Angabe einer umschließenden Fläche <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=48.0&amp;lon=11.5&amp;zoom=10&amp;Q=area%5Bname%3D%22M%C3%BCnchen%22%5D%3B%0Anwr%28area%29%5Bname%3D%22Viktualienmarkt%22%5D%3B%0Aout%20geom%3B">können helfen</a>:</p>

<pre>
<codeline>area[name="München"];</codeline>
<codeline>nwr(area)[name="Viktualienmarkt"];</codeline>
<codeline>out geom;</codeline>
</pre>

<p>Das bzw. die gewünschten Objekte stehen hier nach Zeile 2 im Set <code>_</code>.</p>

<p>Wir könnten nun alle Objekte im Umkreis von 100 Metern um den Kölner Dom <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=50.94&amp;lon=6.96&amp;zoom=14&amp;Q=nwr%5Bname%3D%22K%C3%B6lner%20Dom%22%5D%3B%0Anwr%28around%3A100%29%3B%0Aout%20geom%3B">finden</a>:</p>

<pre>
<codeline>nwr[name="Kölner Dom"];</codeline>
<codeline>nwr(around:100);</codeline>
<codeline>out geom;</codeline>
</pre>

<p>Allerdings warnt Overpass Turbo zurecht vor der Größe der zurückkommenden Datenmenge.
Es erschließt sich auch nicht unmittelbar,
warum eigentlich Gleise zwischen Paris und Brüssel als in der Nähe des Kölner Doms gelten sollen.
Das Problem sind daher einmal mehr räumlich ausgedehnte <em>Relations</em>.
Da dies beim Viktualienmarkt wegen Fernwander- und Radwegen <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=48.135&amp;lon=11.575&amp;zoom=14&amp;Q=area%5Bname%3D%22M%C3%BCnchen%22%5D%3B%0Anwr%28area%29%5Bname%3D%22Viktualienmarkt%22%5D%3B%0Anwr%28around%3A100%29%3B%0Aout%20geom%3B">kaum besser</a> ist ...</p>

<pre>
<codeline>area[name="München"];</codeline>
<codeline>nwr(area)[name="Viktualienmarkt"];</codeline>
<codeline>nwr(around:100);</codeline>
<codeline>out geom;</codeline>
</pre>

<p>... lässt sich vermuten, dass es sich um ein häufiges Problem handelt.
Dies setzt der Nutzbarkeit des <em>Around</em>-Filters ohne weitere Filter enge Grenzen.</p>

<p>Auf der technischen Ebene haben wir wieder unsere benannten Objekte vor Zeile 3 im Set <code>_</code>.
Das Statement <em>Around</em> filtert nun aus allen Objekten nur diejenigen heraus,
die zu mindestens einem Objekt im Set <code>_</code> einen Abstand von höchstens dem angegebenen Wert <code>100</code> in Metern haben.</p>

<p>Der Mechanismus zur Verkettung hat <a href="../criteria/chaining.html#lateral">ein eigenes Unterkapitel</a>, und Sets sind in <a href="../preface/design.html#sets">der Einleitung</a> eingeführt worden.
Das Beispiel <a href="../preface/design.html#sequential">dort vom Anfang</a> zeigt eine Anwendung der <em>Around</em>-Filters,
die hilfreich ist,
da sie den Filter mit einem Filter nach einem Tag <a href="../criteria/union.html#intersection">kombiniert</a>.
Werkzeuge gegen übergroße Datenmengen sind im Unterkapiel <a href="osm_types.html#full">Geometrien</a> diskutiert worden.</p>

<p>Eine weitere mögliche Lösung, um den obigen Fall zumindest sinnvoll anzeigen zu können,
wäre nach <em>Ways</em> statt nach allen Objekten zu filtern und nur die <em>Relations</em> zu ermitteln,
die die gefundenen <em>Ways</em> referenzieren;
für den <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=50.94&amp;lon=6.96&amp;zoom=14&amp;Q=nwr%5Bname%3D%22K%C3%B6lner%20Dom%22%5D%3B%0Away%28around%3A100%29%3B%0Aout%20geom%3B%0Arel%28bw%29%3B%0Aout%3B">Kölner Dom</a>:</p>

<pre>
<codeline>nwr[name="Kölner Dom"];</codeline>
<codeline>way(around:100);</codeline>
<codeline>out geom;</codeline>
<codeline>rel(bw);</codeline>
<codeline>out;</codeline>
</pre>

<p>Zeile 1 bringt die benannten Objekte ins Set <code>_</code>;
Zeile 2 findet alle <em>Ways</em>,
die zu mindestens einem der Objekte aus dem Set <code>_</code> höchstens 100 Meter Abstand haben;
das Ergebnis ersetzt den Inhalt von Set <code>_</code>.
Zeile 3 gibt den Inhalt von Set <code>_</code> aus, also die in Zeile 2 gefundenen <em>Ways</em>.
Zeile 4 findet alle <em>Relations</em>, die mindestens einen der im Set <code>_</code> abgelegten <em>Ways</em> referenzieren
und ersetzt den Inhalt von <code>_</code> durch dieses Ergebnis.
In Zeile 5 wird der Inhalt von Set <code>_</code>, also die gefundenen <em>Relations</em>, ausgegeben,
aber im Gegensatz zu Zeile 3 werden keine Koordinaten mitgeliefert -
dies schrumpft die <em>Relations</em> auf eine handhabbare Größe.</p>

<p><a name="absolute_around"/></p>

<h2>Around-Filter mit Koordinaten</h2>

<p>Im Umkreis kann auch anhand von Koordinaten statt vorhandener Objekte gesucht werden.
Ein Beispiel nahe Greenwich <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.477&amp;lon=0.0&amp;zoom=15&amp;Q=nwr%28around%3A100%2C51%2E477%2C0%2E0%29%3B%0Aout%20geom%3B">auf dem Nullmeridian</a>:</p>

<pre>
<codeline>nwr(around:100,51.477,0.0);</codeline>
<codeline>out geom;</codeline>
</pre>

<p>Es kommt ein Filter in Zeile 1 zum Einsatz:
es werden alle Objekte im Set <code>_</code> abgelegt,
die höchstens 100 Meter Abstand zu der gegebenen Koordinate haben.
Zeile 2 gibt das Set <code>_</code> aus.</p>

<p>Es gelten die gleichen Vorsichtshinweise wie bei allen anderen Volldaten-Suchen mit <em>Relations</em>:
sehr schnell hat man sehr viele Daten.
Die Reduktionstechniken von <a href="osm_types.html#full">Bounding-Boxen</a> und <a href="polygon.html#around">aus dem letzten Abschnitt</a> greifen hier aber ebenfalls.</p>

<p>Es gibt aber keinen Zwang nach <em>Relations</em> zu suchen.
Man kann auch nur nach <em>Nodes</em>, <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.477&amp;lon=0.0&amp;zoom=15&amp;Q=way%28around%3A100%2C51%2E477%2C0%2E0%29%3B%0Aout%20geom%3B">nur nach <em>Ways</em></a> ...</p>

<pre>
<codeline>way(around:100,51.477,0.0);</codeline>
<codeline>out geom;</codeline>
</pre>

<p>... oder nach <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.477&amp;lon=0.0&amp;zoom=15&amp;Q=%28%0A%20%20node%28around%3A100%2C51%2E477%2C0%2E0%29%3B%0A%20%20way%28around%3A100%2C51%2E477%2C0%2E0%29%3B%0A%29%3B%0Aout%20geom%3B"><em>Nodes</em> und <em>Ways</em></a> suchen:</p>

<pre>
<codeline>(</codeline>
<codeline>  node(around:100,51.477,0.0);</codeline>
<codeline>  way(around:100,51.477,0.0);</codeline>
<codeline>);</codeline>
<codeline>out geom;</codeline>
</pre>

<p>Hier nutzen wir ein <em>Union</em>-Statement (wird <a href="../criteria/union.html#union">später</a> eingeführt),
um die Ergebnisse der Umkreissuche nach <em>Nodes</em> und der Umkreissuche nach <em>Ways</em> zusammenzuführen.
Zeile 2 und Zeile 3 filtern je einen Objekttyp anhand eines <em>Around</em>-Filters,
und <em>Union</em> fügt die Ergebnisse beider <em>Query</em>-Statements im Set <code>_</code> zusammen.</p>

<p>Damit werden auch Umkreise mit einem Radius von 1000 Metern und mehr durchführbar.</p>

<p>Relationen kann man jetzt ähnlich wie oben ohne Geometrie wieder <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.477&amp;lon=0.0&amp;zoom=15&amp;Q=%28%0A%20%20node%28around%3A1000%2C51%2E477%2C0%2E0%29%3B%0A%20%20way%28around%3A1000%2C51%2E477%2C0%2E0%29%3B%0A%29%3B%0Aout%20geom%3B%0Arel%28%3C%29%3B%0Aout%3B">hinzunehmen</a>:</p>

<pre>
<codeline>(</codeline>
<codeline>  node(around:1000,51.477,0.0);</codeline>
<codeline>  way(around:1000,51.477,0.0);</codeline>
<codeline>);</codeline>
<codeline>out geom;</codeline>
<codeline>rel(&lt;);</codeline>
<codeline>out;</codeline>
</pre>

<p>In Zeile 5 steht als Eingabe im Set <code>_</code> noch das Ergebnis des <em>Union</em>-Statements zur Verfügung.
Der Filter <code>(&lt;)</code> lässt nur Objekte zu,
die auf mindestens ein Objekt in der Eingabe referenzieren -
das sind genau die Relationen, die einen Bezug zum Suchgebiet haben.</p>

<p>Um mit Suchen umzugehen,
die nicht gut in Bounding-Boxen passen,
stellen wir hier noch die Umkreissuche um einen Linienzug vor.
Dazu definiert man einen Pfad über zwei oder mehr Koordinaten,
und es werden alle Objekte gefunden,
deren Abstand <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.477&amp;lon=0.0&amp;zoom=13&amp;Q=%28%0A%20%20node%28around%3A100%2C51%2E477%2C0%2E0%2C51%2E46%2C%2D0%2E03%29%3B%0A%20%20way%28around%3A100%2C51%2E477%2C0%2E0%2C51%2E46%2C%2D0%2E03%29%3B%0A%29%3B%0Aout%20geom%3B%0Arel%28%3C%29%3B%0Aout%3B">geringer</a> als der angegebene Wert in Metern ist:</p>

<pre>
<codeline>(</codeline>
<codeline>  node(around:100,51.477,0.0,51.46,-0.03);</codeline>
<codeline>  way(around:100,51.477,0.0,51.46,-0.03);</codeline>
<codeline>);</codeline>
<codeline>out geom;</codeline>
<codeline>rel(&lt;);</codeline>
<codeline>out;</codeline>
</pre>

<p>Gegenüber der vorangehenden Abfrage haben sich nur die Zeilen 2 und 3 geändert;
die Koordinaten werden jeweils mit Kommata getrennt aneinandergehängt.</p>

<p><a name="polygon"/></p>

<h2>Polygone als Begrenzung</h2>

<p>Eine weitere Methode,
um mit Suchgebieten umzugehen,
die nur schlecht in Bounding-Boxen passen,
ist die Suche anhand eines Polygons.</p>

<p>Zwar decken <a href="area.html">Areas</a> bereits sehr viele Anwendungsfälle ab,
indem sie die Suche in exakt einem benannten Gebiet erlauben.
Aber wenn es darum geht, solche Gebiete etwas zu erweitern oder auch beliebige Freiformen zu schneiden,
muss zwangsläufig die Flächenbegrenzung als explizites Polygon übergeben werden.</p>

<p>Zur Illustration zunächst eine Suche nur nach Nodes <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.477&amp;lon=0.0&amp;zoom=14&amp;Q=node%28poly%3A%2251%2E47%20%2D0%2E01%2051%2E477%200%2E01%2051%2E484%20%2D0%2E01%22%29%3B%0Aout%20geom%3B">mit einem Dreieck als Grenze</a>,
um die Polygonform gut auf der Karte sehen zu können:</p>

<pre>
<codeline>node(poly:"51.47 -0.01 51.477 0.01 51.484 -0.01");</codeline>
<codeline>out geom;</codeline>
</pre>

<p>In Zeile 1 suchen wir nach <em>Nodes</em>,
und der Filter <code>(poly:...)</code> lässt nur solche Objekte zu,
die innerhalb des in den Anführungszeichen notierten Polygons liegen.
Das Polygon ist eine Liste von Koordinaten der Form Breitengrad-Längengrad,
wobei zwischen den Zahlwerten nur Leerzeichen liegen dürfen.
Nach der letzten Koordinate ergänzt Overpass API die schließende Kante.</p>

<p>Sehr viele Daten liefert wieder einmal die <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.477&amp;lon=0.0&amp;zoom=14&amp;Q=nwr%28poly%3A%2251%2E47%20%2D0%2E01%2051%2E477%200%2E01%2051%2E484%20%2D0%2E01%22%29%3B%0Aout%20geom%3B">Suche nach allen drei Objektarten</a>:</p>

<pre>
<codeline>nwr(poly:"51.47 -0.01 51.477 0.01 51.484 -0.01");</codeline>
<codeline>out geom;</codeline>
</pre>

<p>Wie schon <a href="polygon.html#around">zuvor</a> kann dies durch die beiden Schritte <em>Nodes</em> plus <em>Ways</em> und Rückwärtsauflösen der <em>Relations</em> eingehegt werden;
die Datenersparnis entsteht nur dadurch, dass zu den <em>Relations</em> <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.477&amp;lon=0.0&amp;zoom=14&amp;Q=%28%0A%20%20node%28poly%3A%2251%2E47%20%2D0%2E01%2051%2E477%200%2E01%2051%2E484%20%2D0%2E01%22%29%3B%0A%20%20way%28poly%3A%2251%2E47%20%2D0%2E01%2051%2E477%200%2E01%2051%2E484%20%2D0%2E01%22%29%3B%0A%29%3B%0Aout%20geom%3B%0Arel%28%3C%29%3B%0Aout%3B">die Geometrie weggelassen wird</a>:</p>

<pre>
<codeline>(</codeline>
<codeline>  node(poly:"51.47 -0.01 51.477 0.01 51.484 -0.01");</codeline>
<codeline>  way(poly:"51.47 -0.01 51.477 0.01 51.484 -0.01");</codeline>
<codeline>);</codeline>
<codeline>out geom;</codeline>
<codeline>rel(&lt;);</codeline>
<codeline>out;</codeline>
</pre>

<p>Können auch Löcher und mehrere Komponenten realisiert werden?</p>

<p>Mehrere Komponenten können per <em>Union</em>-Statement realisiert werden.
Da <em>Union</em>-Statements beliebig viele Unterstatements haben können,
können wir die <em>Query</em>-Statements für die Komponenten einfach hintereinander schreiben,
hier gleich für <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.487&amp;lon=0.0&amp;zoom=13&amp;Q=%28%0A%20%20node%28poly%3A%2251%2E47%20%2D0%2E01%2051%2E477%200%2E01%2051%2E484%20%2D0%2E01%22%29%3B%0A%20%20way%28poly%3A%2251%2E47%20%2D0%2E01%2051%2E477%200%2E01%2051%2E484%20%2D0%2E01%22%29%3B%0A%20%20node%28poly%3A%2251%2E491%20%2D0%2E01%2051%2E498%20%2D0%2E03%2051%2E505%20%2D0%2E01%22%29%3B%0A%20%20way%28poly%3A%2251%2E491%20%2D0%2E01%2051%2E498%20%2D0%2E03%2051%2E505%20%2D0%2E01%22%29%3B%0A%29%3B%0Aout%20geom%3B%0Arel%28%3C%29%3B%0Aout%3B">die <em>Nodes</em>-und-<em>Ways</em>-Variante</a>:</p>

<pre>
<codeline>(</codeline>
<codeline>  node(poly:"51.47 -0.01 51.477 0.01 51.484 -0.01");</codeline>
<codeline>  way(poly:"51.47 -0.01 51.477 0.01 51.484 -0.01");</codeline>
<codeline>  node(poly:"51.491 -0.01 51.498 -0.03 51.505 -0.01");</codeline>
<codeline>  way(poly:"51.491 -0.01 51.498 -0.03 51.505 -0.01");</codeline>
<codeline>);</codeline>
<codeline>out geom;</codeline>
<codeline>rel(&lt;);</codeline>
<codeline>out;</codeline>
</pre>

<p>Der Umriss wird hier jeweils zweimal angegeben;
dies lässt sich im Moment leider nicht sinnvoll vermeiden.</p>

<p>Entsprechend könnte es für Löcher naheliegend sein,
das Block-Statement <a href="../criteria/chaining.html#difference">Difference</a> zu verwenden.
Dann schneidet man allerdings auch Objekte weg,
die teilweise im Loch und teilweise im umgebenden Polygon liegen,
denn Difference würde diese Objekte im Loch ja finden.</p>

<p>Stattdessen funktioniert es,
den zum ersten Punkt des Lochs nächstgelegenen Punkt der Außenlinie zu verdoppeln
und den Linienzug mit gedoppeltem Start- und Endpunkt dazwischen einzufügen.</p>

<p>Wenn wir z.B. aus dem Dreieck <code>51.47 -0.01 51.477 0.01 51.484 -0.01</code>
das Dreieck <code>51.483 -0.0093 51.471 -0.0093 51.477 0.008</code> ausschneiden wollen, dann</p>

<ul>
<li>duplizieren wir zunächst den nächstgelegenen Punkt <code>51.484 -0.01</code>,
erhalten also <code>51.47 -0.01 51.477 0.01 51.484 -0.01 51.484 -0.01</code></li>
<li>wiederholen den ersten Punkt des Lochs <code>51.483 -0.0093</code> am Ende,
erhalten also fürs Loch <code>51.483 -0.0093 51.471 -0.0093 51.477 0.008 51.483 -0.0093</code></li>
<li>fügen das Loch zwischen den beiden Kopien des duplizierten Punktes ein:
<code>51.47 -0.01 51.477 0.01 51.484 -0.01 51.483 -0.0093 51.471 -0.0093 51.477 0.008 51.483 -0.0093 51.484 -0.01</code></li>
</ul>

<p>Zur Illustration die <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.477&amp;lon=0.0&amp;zoom=14&amp;Q=node%28poly%3A%2251%2E47%20%2D0%2E01%2051%2E477%200%2E01%2051%2E484%20%2D0%2E01%0A%20%2051%2E483%20%2D0%2E0093%2051%2E471%20%2D0%2E0093%2051%2E477%200%2E008%0A%20%2051%2E483%20%2D0%2E0093%2051%2E484%20%2D0%2E01%22%29%3B%0Aout%20geom%3B">fertige Abfrage für Nodes</a>.
Sie funktioniert auch für alle anderen Objekttypen und kann mit <em>Union</em> kombiniert werden,
aber dann sieht man schlechter das tatsächlich durch das Polygon ausgewählte Gebiet:</p>

<pre>
<codeline>node(poly:"51.47 -0.01 51.477 0.01 51.484 -0.01</codeline>
<codeline>  51.483 -0.0093 51.471 -0.0093 51.477 0.008</codeline>
<codeline>  51.483 -0.0093 51.484 -0.01");</codeline>
<codeline>out geom;</codeline>
</pre>
<hr/>
<p>weiter: <a href="area.html">Suche per Area</a></p>

</body>
</html>
