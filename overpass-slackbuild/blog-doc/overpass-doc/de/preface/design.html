<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
pre { background-color:#ccffff; padding: 0.5em; counter-reset: line; }
div[type=sibling] { text-indent:1em; }
codeline::before { counter-increment: line; content: counter(line)" "; color: #99cccc; }
</style>
  <title>Laufzeitmodell</title>
</head>
<body style="font-family:sans-serif; max-width:32em">

<p><a href="../index.html">Handbuch zur Overpass API</a>  </p>

<nav>
<div type="parent"><strong><a href="index.html">Einführung</a></strong></div>

<div type="sibling"><a href="preface.html">OpenStreetMap und die Overpass API</a></div>
<div type="sibling"><a href="osm_data_model.html">OpenStreetMap-Datenmodell</a></div>
<div type="sibling"><a href="glossary.html">Glossar</a></div>
<div type="sibling"><strong> Laufzeitmodell</strong></div>
<div type="sibling"><a href="assertions.html">Grundsätze</a></div>
<div type="sibling"><a href="commons.html">Allmende</a></div>

</nav>
<div type="parent"><a href="../targets/index.html">Verwendung</a></div>
<div type="parent"><a href="../full_data/index.html">Räumliche Datenauswahl</a></div>
<div type="parent"><a href="../criteria/index.html">Objekte Finden</a></div>
<div type="parent"><a href="../counting/index.html">Objekte Zählen</a></div>
<div type="parent"><a href="../analysis/index.html">Daten Analysieren</a></div>
<div type="parent"><a href="../more_info/index.html">Anhang</a></div>

<hr />

<h1>Laufzeitmodell</h1>

<p>Nach welchen Regeln führt die Overpass API eine Abfrage aus?
Die Vorstellung der einzelnen Bausteine schafft das Verständnis,
wie diese in Abfragen zusammenwirken.</p>

<nav>
<h3>Inhalt</h3>

<div type="subsection"><a href="design.html#sequential">Anweisung für Anweisung</a></div>
<div type="subsection"><a href="design.html#statements">Statements, Filter</a></div>
<div type="subsection"><a href="design.html#block_statements">Block-Statements</a></div>
<div type="subsection"><a href="design.html#evaluators">Evaluators und Deriveds</a></div>
<div type="subsection"><a href="design.html#sets">Mehrere Auswahlen gleichzeitig</a></div>

</nav>

<p><a name="sequential"/></p>

<h2>Anweisung für Anweisung</h2>

<p>Die meisten fortgeschrittenen Anwendungsfälle für Abfragen erfordern relative Auswahlen.
Ein gutes Beispiel sind Supermärkte,
die nahe an einem Bahnhof liegen.
Die Supermärkte sind mit den Bahnhöfen nur dadurch verbunden,
dass sie räumlich nahe beieinander sind.</p>

<p>Dem Satzbau zufolge suchen wir eigentlich erst Supermärkte,
suchen dann an jedem Supermarkt nach Bahnhöfen in der Nähe
und behalten nur Supermärkte in der Auswahl, bei denen wir einen Bahnhof gefunden haben.
Diese Herangehensweise führt bei natürlicher Sprache schnell zu Relativsatzungetümen;
auch in formaler Sprache wird das nicht besser.</p>

<p>Daher folgt die Abfragesprache der Ovepass API stattdessen einem Schritt-für-Schritt-Paradigma,
der sogenannten <em>imperativen Programmierung</em>.
Zu jedem Zeitpunkt wird nur eine überschaubare Aufgabe gelöst,
und die komplexe Aufgabe durch Aneinanderreihung bewältigt.
Das Herangehen ist dann wie folgt:</p>

<ul>
<li>Wähle alle Bahnhöfe im Zielgebiet aus</li>
<li>Ersetze die Auswahl durch alle Supermärkte in der Nähe dieser Bahnhöfe</li>
<li>Gib die Liste der Supermärkte aus</li>
</ul>

<p>Das ergibt Zeile für Zeile folgende Abfrage.
Sie können sie jetzt <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=13&amp;Q=nwr%5Bpublic_transport%3Dstation%5D%28%7B%7Bbbox%7D%7D%29%3B%0Anwr%5Bshop%3Dsupermarket%5D%28around%3A100%29%3B%0Aout%20center%3B">ausführen</a>:</p>

<pre>
<codeline>nwr[public_transport=station]({{bbox}});</codeline>
<codeline>nwr[shop=supermarket](around:100);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Die Details der Syntax werden später erläutert.</p>

<p>Für einfachere Fälle mag man zwar eine noch einfachere Syntax wünschen,
aber die entstehende Zwei-Zeilen-Lösung spiegelt die klare Aufgabenteilung wider:</p>

<pre>
<codeline>nwr[shop=supermarket]({{bbox}});</codeline>
<codeline>out center;</codeline>
</pre>

<ul>
<li>Die Auswahlanweisung oder -anweisungen legen fest, <em>was</em> ausgegeben wird.</li>
<li>Die Ausgabeanweisung <em>out</em> legt fest, <em>wie</em> die angewählten Objekte ausgegeben werden. Details dazu bei den <a href="../targets/formats.html#faithful">Ausgabeformaten</a></li>
</ul>

<p><a name="statements"/></p>

<h2>Statements, Filter</h2>

<p>Wir vergleichen die Abfrage nach einfach nur den Supermärkten im Sichtbarkeitsbereich</p>

<pre>
<codeline>nwr[shop=supermarket]({{bbox}});</codeline>
<codeline>out center;</codeline>
</pre>

<p>mit der obigen Abfrage</p>

<pre>
<codeline>nwr[public_transport=station]({{bbox}});</codeline>
<codeline>nwr[shop=supermarket](around:100);</codeline>
<codeline>out center;</codeline>
</pre>

<p>um die einzelnen Komponenten zu identifizieren.</p>

<p>Das wichtigste Zeichen ist das Semikolon; es beendet jeweils ein <em>Statement</em>.
Zeilenumbrüche, Leerzeichen (und Tabulatoren) sind dafür und auch für die Syntax insgesamt irrelevant.
Diese <em>Statements</em> werden nacheinander in der Reihenfolge ausgeführt,
in der sie aufgeschrieben sind.
In beiden Abfragen gibt es also zusammen vier Statements:</p>

<ul>
<li><code>nwr[shop=supermarket]({{bbox}});</code></li>
<li><code>nwr[public_transport=station]({{bbox}});</code></li>
<li><code>nwr[shop=supermarket](around:100);</code></li>
<li><code>out center;</code></li>
</ul>

<p>Das Statement <code>out center</code> ist ein Ausgabestatement ohne weitere Unterstrukturen.
Die Möglichkeiten, das Ausgabeformat zu steuern, werden im Abschnitt <a href="../targets/formats.html">Datenformate</a> thematisiert.</p>

<p>Die übrigen <em>Statements</em> sind alle <em>query</em>-Statements, d.h. sie dienen dazu Objekte anzuwählen.
Dies gilt für alle mit <code>nwr</code> beginnenden Statements und weitere spezielle Schlüsselwörter:
die Schlüsselwörter <code>node</code>, <code>way</code> und <code>relation</code> wählen gezielt die entsprechende Objektart,
und <code>nwr</code> (kurz für <em>nodes, ways, relations</em>) lässt alle Objektarten im Ergebnis zu.
Die <em>query</em>-Statements haben hier mehrfach auftretende Unterstrukturen:</p>

<ul>
<li><code>[shop=supermarket]</code> und <code>[public_transport=station]</code></li>
<li><code>({{bbox}})</code></li>
<li><code>(around:100)</code></li>
</ul>

<p>Alle Unterstrukturen eines <em>query</em>-Statements filtern die anzuwählenden Objekte und heißen daher <em>Filter</em>.
Es ist möglich, beliebig viele Filter in einem Statement zu kombinieren;
das <em>query</em>-Statement wählt genau solche Objekte an,
die alle Filter erfüllen.
Die Reihenfolge der Filter spielt keine Rolle,
denn die Filter eines Statements werden gleichzeitig angewendet.</p>

<p>Während <code>[shop=supermarket]</code> und <code>[public_transport=station]</code> alle Objekte zulassen,
die ein spezifisches Tag besitzen (Supermärkte im einen Fall, Bahnhöfe im anderen),
dienen <code>({{bbox}})</code> und <code>(around:100)</code> der räumlichen Filterung.</p>

<p>Der Filter <code>({{bbox}})</code> lässt genau solche Objekte zu,
die ganz oder teilweise in der übergebenen Bounding-Box liegen.</p>

<p>Etwas komplizierter arbeitet <code>(around:100)</code>.
Es benötigt eine Vorgabe und lässt genau alle Objekte zu,
die zu irgendeinem der Vorgabe-Objekte einen Abstand von höchstens 100 Metern haben.</p>

<p>Hier greift die Schritt-für-Schritt-Ausführung:
Der Filter <code>(around:100)</code> erhält hier als Eingabe exakt die in der vorhergehenden Zeile ausgewählten Bahnhöfe.</p>

<p><a name="block_statements"/></p>

<h2>Block-Statements</h2>

<p>Wie kann man eine Oder-Verknpüfung erreichen?
<a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=14&amp;Q=%28%0A%20%20nwr%5Bpublic%5Ftransport%3Dstation%5D%28%7B%7Bbbox%7D%7D%29%3B%0A%20%20nwr%5Bshop%3Dsupermarket%5D%28%7B%7Bbbox%7D%7D%29%3B%0A%29%3B%0Aout%20center%3B">Auf diese Weise</a> findet man alle Objekte, die ein Supermarkt <em>oder</em> ein Bahnhof sind:</p>

<pre>
<codeline>(</codeline>
<codeline>  nwr[public_transport=station]({{bbox}});</codeline>
<codeline>  nwr[shop=supermarket]({{bbox}});</codeline>
<codeline>);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Hier bilden die beiden <em>query</em>-Statements einen Block innerhalb einer größeren Struktur.
Die durch die Klammern gekennzeichnete Struktur heißt daher <em>Block-Statement</em>.</p>

<p>Diese spezielle Block-Struktur heißt <em>union</em>,
und sie dient dazu, mehrere Statements so zu verknüpfen,
dass sie alle Objekte anwählt,
die in irgendeinem der Statements im Block gefunden werden.
Es muss mindestens eine und es können beliebig viele Statements im Block stehen.</p>

<p>Es gibt zahlreiche weitere Block-Statements:</p>

<ul>
<li>Das Block-Statement <em>difference</em> erlaubt, eine Auswahl aus einer anderen auszuschneiden.</li>
<li><em>if</em> führt seinen Block nur aus, wenn die im Kopf stehende Bedingung erfüllt ist.
Auch ein zweiter Block ist möglich;
dieser wird ausgeführt, wenn die Bedingung zu falsch auswertet.</li>
<li><em>foreach</em> führt seinen Block einmal pro Objekt in seiner Eingabe aus.</li>
<li><em>for</em> fasst die Objekte erst zu Gruppen zusammen und führt dann seinen Block einmal pro Gruppe aus.</li>
<li><em>complete</em> erfüllt Aufgaben einer <em>while</em>-Schleife.</li>
<li>Weitere Block-Statements erlauben es, gelöschte oder überholte Daten wieder zurückzuholen.</li>
</ul>

<p><a name="evaluators"/></p>

<h2>Evaluators und Deriveds</h2>

<p>Nicht geklärt ist damit,
wie im Block-Statement <em>if</em> oder auch <em>for</em> die Bedingungen formuliert werden können.</p>

<p>Der dafür genutzte Mechanismus hilft aber auch für andere Aufgaben.
Man kann damit z.B. eine <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=16&amp;Q=%5Bout%3Acsv%28name%29%5D%3B%0Away%5Bhighway%5D%28%7B%7Bbbox%7D%7D%29%3B%0Afor%20%28t%5B%22name%22%5D%29%0A%7B%0A%20%20make%20Beispiel%20name%3D%5F%2Eval%3B%0A%20%20out%3B%0A%7D">Liste aller Straßennamen</a> in einem Gebiet erstellen.</p>

<pre>
<codeline>[out:csv(name)];</codeline>
<codeline>way[highway]({{bbox}});</codeline>
<codeline>for (t["name"])</codeline>
<codeline>{</codeline>
<codeline>  make Beispiel name=_.val;</codeline>
<codeline>  out;</codeline>
<codeline>}</codeline>
</pre>

<p>Die Zeilen 2 und 6 enthalten die einfachen Statements <code>way[highway]({{bbox}})</code> bzw. <code>out</code>.
Mit <code>[out:csv(name)]</code> in Zeile 1 wird das Ausgabeformat gesteuert (<a href="../targets/index.html">siehe dort</a>).
Die Zeilen 3, 4 und 7 bilden das Block-Statement <code>for (t["name"])</code>;
dieses muss wissen, nach welchem Kriterium es gruppieren soll.</p>

<p>Dies wird durch den <em>Evaluator</em> <code>t["name"]</code> beantwortet.
Ein <em>Evaluator</em> ist ein Ausdruck,
der im Rahmen der Ausführung eines Statements ausgewertet sind.</p>

<p>Hier handelt es sich um einen Ausdruck, der pro Element ausgewertet wird,
da <em>for</em> pro Element Informationen benötigt.
Der Ausdruck <code>t["name"]</code> wertet zu einem Objekte den Wert von dessen Tag mit Schlüssel <em>name</em> aus.
Hat das Objekt kein Tag mit Schlüssel <em>name</em>,
so liefert der Ausdruck eine leere Zeichenkette als Wert.</p>

<p>Zeile 5 enthält mit <code>_.val</code> ebenfalls einen <em>Evaluator</em>.
Hier geht es darum, den auszugebenden Wert zu erzeugen.
Das Statement <em>make</em> erzeugt stets nur ein Objekt aus potentiell vielen Objekten,
daher darf der Wert von <code>_.val</code> nicht von einzelnen Objekten abhängen.
Der Evalutor <code>_.val</code> liefert innerhalb einer Schleife den Wert des aktuellen Schleifenausdrucks,
hier also den Wert des Tags <em>name</em> aller hier einschlägigen Objekte.</p>

<p>Wenn ein unabhängiger Wert erwartet, aber ein objektabhängiger Wert angegeben wird,
führt dies zu einer Fehlermeldung.
Das passiert z.B., wenn wir uns die Längen der Straßen ausgeben lassen wollten:
<a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=16&amp;Q=%5Bout%3Acsv%28length%2Cname%29%5D%3B%0Away%5Bhighway%5D%28%7B%7Bbbox%7D%7D%29%3B%0Afor%20%28t%5B%22name%22%5D%29%0A%7B%0A%20%20make%20Beispiel%20name%3D%5F%2Eval%2Clength%3Dlength%28%29%3B%0A%20%20out%3B%0A%7D">Probieren</a> Sie es bitte aus:</p>

<pre>
<codeline>[out:csv(length,name)];</codeline>
<codeline>way[highway]({{bbox}});</codeline>
<codeline>for (t["name"])</codeline>
<codeline>{</codeline>
<codeline>  make Beispiel name=_.val,length=length();</codeline>
<codeline>  out;</codeline>
<codeline>}</codeline>
</pre>

<p>Die verschiedene Segmente einer Straße gleichen Namens können verschiedene Längen haben.
Wir können dies beheben, indem wir vorgeben, auf welche Art die Objekte zusammengefasst werden sollen.
Häufig möchte man <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=16&amp;Q=%5Bout%3Acsv%28length%2Cname%29%5D%3B%0Away%5Bhighway%5D%28%7B%7Bbbox%7D%7D%29%3B%0Afor%20%28t%5B%22name%22%5D%29%0A%7B%0A%20%20make%20Beispiel%20name%3D%5F%2Eval%2Clength%3Dset%28length%28%29%29%3B%0A%20%20out%3B%0A%7D">eine Liste</a>:</p>

<pre>
<codeline>[out:csv(length,name)];</codeline>
<codeline>way[highway]({{bbox}});</codeline>
<codeline>for (t["name"])</codeline>
<codeline>{</codeline>
<codeline>  make Beispiel name=_.val,length=set(length());</codeline>
<codeline>  out;</codeline>
<codeline>}</codeline>
</pre>

<p>In diesem speziellen Fall dürfte aber Summieren <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=16&amp;Q=%5Bout%3Acsv%28length%2Cname%29%5D%3B%0Away%5Bhighway%5D%28%7B%7Bbbox%7D%7D%29%3B%0Afor%20%28t%5B%22name%22%5D%29%0A%7B%0A%20%20make%20Beispiel%20name%3D%5F%2Eval%2Clength%3Dsum%28length%28%29%29%3B%0A%20%20out%3B%0A%7D">sinnvoller sein</a>:</p>

<pre>
<codeline>[out:csv(length,name)];</codeline>
<codeline>way[highway]({{bbox}});</codeline>
<codeline>for (t["name"])</codeline>
<codeline>{</codeline>
<codeline>  make Beispiel name=_.val,length=sum(length());</codeline>
<codeline>  out;</codeline>
<codeline>}</codeline>
</pre>

<p>Das Statement <em>make</em> erzeugt immer genau ein neues Objekt, ein sogenanntes <em>Derived</em> (von englisch: abgeleitet).
Warum überhaupt ein Objekt, warum nicht einfach ein OpenStreetMap-Objekt?
Die Gründe dafür variieren von Anwendung zu Anwendung:
hier brauchen wir etwas, das wir ausgeben können.
In anderen Fällen möchte man Tags von OpenStreetMap-Objekten ändern und entfernen
oder die Geometrie des OpenStreetMap-Objekts vereinfachen
oder braucht einen Träger für spezielle Information.
Scheinbare OpenStreetMap-Objekte müssen den Regeln für OpenStreetMap-Objekte folgen
und lassen daher viele hilfreiche Freiheiten nicht zu.
Vor allem aber könnten sie mit echten OpenStreetMap-Objekten verwechselt und irrtümlich hochgeladen werden.</p>

<p>Die erzeugten Objekte können Sie sehen, wenn Sie als Ausgabeformat es bei XML <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=16&amp;Q=way%5Bhighway%5D%28%7B%7Bbbox%7D%7D%29%3B%0Afor%20%28t%5B%22name%22%5D%29%0A%7B%0A%20%20make%20Beispiel%20name%3D%5F%2Eval%2Clength%3Dsum%28length%28%29%29%3B%0A%20%20out%3B%0A%7D">belassen</a>:</p>

<pre>
<codeline>way[highway]({{bbox}});</codeline>
<codeline>for (t["name"])</codeline>
<codeline>{</codeline>
<codeline>  make Beispiel name=_.val,length=sum(length());</codeline>
<codeline>  out;</codeline>
<codeline>}</codeline>
</pre>

<p><a name="sets"/></p>

<h2>Mehrere Auswahlen gleichzeitig</h2>

<p>In vielen Fällen kommt man aber mit einer einzigen Auswahl nicht aus.
Daher können Auswahlen auch in benannten Variablen abgelegt
und so mehrere Auswahl gleichzeitig behalten werden.</p>

<p>Wir wollen alle Objekte der einen Art finden,
die nicht in der Nähe von Objekten der anderen Art sind.
Praxisnähere Beispiel sind dabei häufig eher Suche nach Fehlern,
z.B. Bahnsteige ohne Gleise oder Adressen ohne Straße.
Wir werden uns aber jetzt nicht mit Feinheiten des Taggings auseinandersetzen.</p>

<p>Wir ermitteln daher alle Supermärkte,
die <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=14&amp;Q=nwr%5Bpublic%5Ftransport%3Dstation%5D%28%7B%7Bbbox%7D%7D%29%2D%3E%2Eall%5Fstations%3B%0A%28%0A%20%20nwr%5Bshop%3Dsupermarket%5D%28%7B%7Bbbox%7D%7D%29%3B%0A%20%20%2D%20nwr%2E%5F%28around%2Eall%5Fstations%3A300%29%3B%0A%29%3B%0Aout%20center%3B">nicht in der Nähe</a> von Bahnhöfen sind:</p>

<pre>
<codeline>nwr[public_transport=station]({{bbox}})-&gt;.all_stations;</codeline>
<codeline>(</codeline>
<codeline>  nwr[shop=supermarket]({{bbox}});</codeline>
<codeline>  - nwr._(around.all_stations:300);</codeline>
<codeline>);</codeline>
<codeline>out center;</codeline>
</pre>

<p>In Zeile 3 wählt das Statement <code>nwr[shop=supermarket]({{bbox}})</code> alle Supermärkte in der Bounding-Box aus.
Wir wollen davon eine Teilmenge abziehen und verwenden daher ein Block-Statement vom Typ <em>difference</em>;
dieses ist an den drei Komponenten <code>(</code> in Zeile 2, <code>-</code> in Zeile 4 und <code>);</code> in Zeile 5 zu erkennen.</p>

<p>Wir müssen Supermärkte in der Nähe von Bahnhöfen auswählen.
Dazu müssen wir wie oben vorher die Bahnhöfe gewählt haben;
wir brauchen aber auch alle Supermärkte als Auswahl.
Daher leiten wir die Auswahl der Bahnhöfe durch die getrennte <em>Set-Variable</em> <code>all_stations</code>.
Sie wird in Zeile 1 von einem gewöhnlichen Statement <code>nwr[public_transport=station]({{bbox}})</code> mittels der Syntax <code>-&gt;.all_stations</code> in eben diese Variable geleitet.
Der Zusatz <code>.all_stations</code> in <code>(around.all_stations:300)</code> sorgt dann dafür,
dass diese Variable als Quelle anstelle der letzten Auswahl verwendet wird.</p>

<p>Damit wäre <code>nwr[shop=supermarket]({{bbox}})(around.all_stations:300)</code> das richtige Statement,
um die genau zu entfernenen Supermärkte anzuwählen.
Zur Verkürzung der Laufzeit nutzen wir aber lieber die Auswahl des unmittelbar vorhergehenden Statements in Zeile 3 - dort stehen ja genau die Supermärkte in der Bounding-Box drin.
Dies passiert mittels des <em>Filters</em> <code>._</code>.
Es schränkt die Auswahl auf solche Ergebnisse ein,
die beim Start des Statements in der Eingabe stehen.
Da wir hier die Standardeingabe benutzt haben,
sprechen wir sie über ihren Namen <code>_</code> (einfacher Unterstrich) an.</p>

<p>Der Ablauf mit Datenfluss nocheinmal im Detail:</p>

<ul>
<li>Vor Beginn der Ausführung sind alle Auswahlen leer.</li>
<li>Zuerst wird Zeile 1 ausgeführt.
Wegen <code>-&gt;.all_stations</code> sind danach alle Bahnhöfe als <code>all_stations</code> ausgewählt;
die Standardauswahl bleibt dagegen leer.</li>
<li>Zeilen 2 bis 5 sind ein Block-Statement vom Typ <em>difference</em>,
und dieses führt zunächst seinen Ausweisungblock aus.
Daher wird als nächstes Zeile 3 <code>nwr[shop=supermarket]({{bbox}})</code> ausgeführt.
Zeile 3 hat keine Umleitung,
so dass danach alle Supermärkte in der Standard-Auswahl ausgewählt sind.
Die Auswahl <code>all_stations</code> wird nicht erwähnt und bleibt daher erhalten.</li>
<li>Das Block-Statement <em>difference</em> greift das Ergebnis seines ersten Operanden ab,
also von Zeile 3.</li>
<li>Zeile 4 benutzt die Standarauswahl per <code>._</code> als Einschränkung für sein Ergebnis,
und zusätzlich wird per <code>(around.all_stations:300)</code> die Auswahl <code>all_stations</code> als Quelle für die Umkreissuche <em>around</em> herangezogen.
Das Ergebnis ist die neue Standard-Auswahl und ersetzt daher die vorherige Standard-Auswahl.
Die Auswahl <code>all_stations</code> bleibt unverändert.</li>
<li>Das Block-Statement <em>difference</em> greift das Ergebnis seines zweiten Operanden ab,
also von Zeile 4.</li>
<li>Das Block-Statement <em>difference</em> bildet jetzt die Differenz der beiden abgegriffenen Ergebnisse.
Da nichts anderes gefordert ist, wird das Ergebnis die neue Standard-Auswahl.
Die Auswahl <code>all_stations</code> bleibt nach wie vor unverändert.</li>
<li>Zuletzt wird Zeile 5 ausgeführt.
Ohne besondere Angabe verwendet <code>out</code> als Quelle die Standard-Auswahl.</li>
</ul>
<hr/>
<p>weiter: <a href="assertions.html">Grundsätze</a></p>

</body>
</html>
