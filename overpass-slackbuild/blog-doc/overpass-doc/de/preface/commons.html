<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
pre { background-color:#ccffff; padding: 0.5em; counter-reset: line; }
div[type=sibling] { text-indent:1em; }
codeline::before { counter-increment: line; content: counter(line)" "; color: #99cccc; }
</style>
  <title>Allmende</title>
</head>
<body style="font-family:sans-serif; max-width:32em">

<p><a href="../index.html">Handbuch zur Overpass API</a>  </p>

<nav>
<div type="parent"><strong><a href="index.html">Einführung</a></strong></div>

<div type="sibling"><a href="preface.html">OpenStreetMap und die Overpass API</a></div>
<div type="sibling"><a href="osm_data_model.html">OpenStreetMap-Datenmodell</a></div>
<div type="sibling"><a href="glossary.html">Glossar</a></div>
<div type="sibling"><a href="design.html">Laufzeitmodell</a></div>
<div type="sibling"><a href="assertions.html">Grundsätze</a></div>
<div type="sibling"><strong> Allmende</strong></div>

</nav>
<div type="parent"><a href="../targets/index.html">Verwendung</a></div>
<div type="parent"><a href="../full_data/index.html">Räumliche Datenauswahl</a></div>
<div type="parent"><a href="../criteria/index.html">Objekte Finden</a></div>
<div type="parent"><a href="../counting/index.html">Objekte Zählen</a></div>
<div type="parent"><a href="../analysis/index.html">Daten Analysieren</a></div>
<div type="parent"><a href="../more_info/index.html">Anhang</a></div>

<hr />

<h1>Allmende</h1>

<p>Es gibt eine öffentliche Instanz, die größtmögliche Ressourcen bereitstellt,
aber auch gegen Übernutzung verteidigt.
Großnutzer können leicht eine eigene Instanz aufsetzen.</p>

<nav>
<h3>Inhalt</h3>

<div type="subsection"><a href="commons.html#magnitudes">Größenordnungen</a></div>
<div type="subsection"><a href="commons.html#quotas">Regeln</a></div>

</nav>

<p><a name="magnitudes"/></p>

<h2>Größenordnungen</h2>

<p>Ziel der öffentlichen Instanzen ist es,
möglichst vielen Nutzern zur Verfügung zu stehen.
Die Rechenleistung der Server muss zwischen den täglich etwa 30.000 Nutzern aufgeteilt werden.</p>

<p>Die typische Abfrage hat eine Laufzeit von unter 1 Sekunde,
es gibt jedoch auch deutlich länger laufende Anfragen.
Jeder Server der Overpass API kann davon etwa 1 Mio. Anfragen pro Tag beantworten,
und es werden zwei Server im Rahmen von <a target="_blank" rel="noopener" href="https://wiki.openstreetmap.org/wiki/Overpass_API#Public_Overpass_API_instances">overpass-api.de</a> betrieben.</p>

<p>Es ist praktisch ausgeschlossen, dass Sie mit manuell ausgelösten Abfragen jemals Schwierigkeiten bereiten.
Leider kann die Ressourcenbegrenzung Sie trotzdem vereinzelt heimsuchen -
der Algorithmus kann nicht perfekt arbeiten.</p>

<p>Beispiele für problematisches Verhalten sind:</p>

<ol>
<li>zehntausende Male pro Tag die exakt gleiche Abfrage (von der gleichen Adresse) auszuführen</li>
<li>millionenweise nach jeweils einem einzelnen Element per Id zu fragen</li>
<li>Bounding-Boxen aneinanderzuhängen, um insgesamt die gesamten Daten der Welt herunterzuladen</li>
<li>eine App für mehr als nur alle OSM-Mapper aufzusetzen
und sich auf die öffentlichen Instanzen als Backend zu verlassen</li>
</ol>

<p>Im ersten Fall muss das abfragende Skript repariert werden,
in den Fällen 2 und 3 sollte anstatt der Overpass API lieber ein <a target="_blank" rel="noopener" href="https://wiki.openstreetmap.org/wiki/Planet.osm">Planet-Dump</a> verwendet werden.
Im vierten Fall ist eine eigene Instanz die bessere Wahl;
Hinweise zur Einrichtung geben die <a href="../more_info/setup.html">Installations-Instruktionen</a>.</p>

<p>Tatsächlich stellen die meisten Nutzer aber nur jeweils wenige Anfragen.
Die automatische Lastbegrenzung zielt also darauf ab,
die ersten paar Abfragen pro Nutzer gegenüber massenhaften Abfragen einzelner Nutzer zu bevorzugen.
Eine manuelle Lastbeschränkung wird also zuerst bei den intensivsten Nutzer orientieren,
und die nachfolgenden Schätzungen zur Maximalnutzung halten von deren Nutzungsintensität einen sicheren Abstand.</p>

<p>Über die öffentlichen Instanzen lässt sich üblicherweise noch ein Abfrageaufkommen abwickeln,
dass weder 10000 Abfragen pro Tag noch 1 GB Downloadvolumen pro Tag überschreitet.</p>

<p>Zu den Zielen gehört aber auch, den Betrieb einer eigenen Instanz möglichst einfach zu gestalten.
Wer seinen Bedarf auf mehr als die obigen Nutzungsgrenzen schätzt,
lese also bitte die <a href="../more_info/setup.html">Installations-Instruktionen</a>.</p>

<p>Wer dagegen mehr über die automatische Lastbegrenzung wissen will oder muss,
lese bitte den folgenden Absatz.</p>

<p><a name="quotas"/></p>

<h2>Regeln</h2>

<p>Die automatische Lastbegrenzung ordnet Abfragen (anonymen) Benutzern zu
und stellt die Erreichbarkeit für Wenignutzer sicher,
wenn das Abfragevolumen aller Nutzer die Serverkapazität übersteigt.</p>

<p>Es gibt derzeit zwei voneinander unabhängige öffentliche Instanzen,
<a target="_blank" rel="noopener" href="https://z.overpass-api.de/api/status">z.overpass-api.de</a> und <a target="_blank" rel="noopener" href="https://lz4.overpass-api.de/api/status">lz4.overpass-api.de</a>.
Wir beginnen mit der Erläuterung dieser Status-Abfragen.</p>

<h3>Rate-Limit</h3>

<p>Die Zuordnung zu Benutzern erfolgt üblicherweise per IP-Adresse.
Ist ein Benutzerschlüssel gesetzt, so wird dieser vorrangig verwendet.
Bei IPv4-Adressen wird die volle IP-Adresse ausgewertet;
bei IPv6-Adressen die oberen 64 Bit der IP-Adresse.
Für IPv6-Adressen ist noch nicht klar,
welche Gepflogenheiten sich durchsetzen,
so dass eine Verkürzung auf weniger Bits vorbehalten bleibt.
Die vom Server ermittelte Benutzernummer steht in der ersten Zeile der <a target="_blank" rel="noopener" href="https://overpass-api.de/api/status">Status-Abfrage</a> hinter <code>Connected as:</code>.</p>

<p>Jede Ausführung einer Abfrage belegt einen Slot des Benutzers,
und zwar für die Ausführungsdauer der Abfrage plus eine Beruhigungszeit.
Der Zweck der Beruhigungszeit ist,
anderen Benutzern die Chance zu Abfragen zu geben.
Die Beruhigungszeit wächst mit der Auslastung des Servers und proportional zur Ausführungsdauer.
Bei geringer Auslastung beträgt die Beruhigungszeit nur einen Bruchteil der Ausführungsdauer,
bei hoher Auslastung auch durchaus ein Vielfaches.</p>

<p>Eine Slippy-Map würde nun viele kurzlaufende Abfragen in kurzer Zeit absetzen.
Damit ein Benutzer alle diese Abfragen beantwortet bekommen kann,
gibt es zwei Kulanzmechanismen:</p>

<ul>
<li>Es gibt üblicherweise mehrere Slots.
Die Anzahl der Slots steht in der dritten Zeile hinter <code>Rate limit:</code>.</li>
<li>Abfragen werden bis zu 15 Sekunden auf dem Server offengehalten,
wenn ihnen noch kein Slot zur Verfügung steht.</li>
</ul>

<p>Benötigt eine solche Slippy-Map also z.B. 20 Abfragen zu 1 Sekunde Laufzeit,
ist die Anzahl der Slots gleich 2 und das Verhältnis von Abfragedauer zu Beruhigungszeit 1:1,
so würden</p>

<ul>
<li>die ersten zwei Abfragen sofort abgewickelt</li>
<li>die nächsten zwei Abfragen entgegengenommen
und nach 2 Sekunden (1 Sekunde Ausführungsdauer plus 1 Sekunde Beruhigungszeit) ausgeführt</li>
<li>die weiteren Abfragen entsprechend später ausgeführt</li>
<li>die Abfragen 15 und 16 an jeweils fünfter Position nach 14 Sekunden ausgeführt</li>
<li>die Abfragen 17 bis 20 nach 15 Sekunden verworfen,
da sie bis dahin keinen Slot bekommen haben</li>
</ul>

<p>Wenn der Benutzer die Inhalte der Abfragen 17 bis 20 noch braucht,
(und nicht bereits weggescrollt hat)
dann sollte das Client-Framework die Abfragen 17 bis 20 nach Ablauf der 15 Sekunden erneut stellen.
Im <a href="../targets/index.html">Abschnitt über OpenLayers und Leaflet</a> gibt es eine Referenz-Implementierung.</p>

<p>Die Grund für diesen Mechanismus sind Skripte in Endlosschleife:
viele führen je eine Abfrage parallel aus und werden dann sinnvoll verzögert,
da ihre Abfragen entsprechend verzögert Antworten erhalten.</p>

<p>Falls langlaufende Abfragen in der Größenordnung von Minuten den Slot belegt haben,
gibt die Status-Abfrage ab Zeile 6 Auskunft darüber,
wann welcher Slot wieder verfügbar ist.</p>

<p>Wegen des Rate-Limits abgelehnte Abfragen werden mit dem <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6585#section-4">HTTP-Statuscode 429</a> beantwortet.</p>

<h3>Timeout und Maxsize</h3>

<p>Unabhängig von diesem Rate-Limit gibt es einen zweiten Mechanismus;
er bevorzugt kleine Abfragen vor großen Abfragen,
damit viele Nutzer mit kleinen Abfragen auch dann noch bedient werden können,
wenn die Kapazität für die Nutzer mit den größten Abfragen zusammen nicht mehr reicht.</p>

<p>Es gibt zwei Kriterien dafür, pro Laufzeit und pro Speicherbedarf.
Jede Abfrage enthält eine Deklaration zu ihrer erwarteten Maximallaufzeit und zu ihrem erwarteten maximalen Speicherbedarf.
Die Deklaration der Maximallaufzeit kann explizit durch ein vorangestelltes <code>[timeout:...]</code> erfolgen;
die Deklaration des maximalen Speicherbedarfs durch ein vorangestelltes <code>[maxsize:...]</code>.
Beides kann kombiniert werden.</p>

<p>Ist bei einer Abfrage keine Maximallaufzeit deklariert,
so wird eine Maximallaufzeit von 180 Sekunden gesetzt.
Für den maximalen Speicherbedarf ist der Defaultwert 536870912;
dies entspricht 512 MiB.</p>

<p>Überschreitet eine Abfrage ihre deklarierte Maximallaufzeit oder ihren deklarierten maximalen Speicherbedarf,
so wird sie vom Server abgebrochen.
Dieses <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=10&amp;Q=%5Btimeout%3A3%5D%3B%0Anwr%5Bshop%3Dsupermarket%5D%28%7B%7Bbbox%7D%7D%29%3B%0Aout%20center%3B">Beispiel</a> bricht nach 3 Sekunden ab:</p>

<pre>
<codeline>[timeout:3];</codeline>
<codeline>nwr[shop=supermarket]({{bbox}});</codeline>
<codeline>out center;</codeline>
</pre>

<p>Das <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=10&amp;Q=%5Btimeout%3A90%5D%3B%0Anwr%5Bshop%3Dsupermarket%5D%28%7B%7Bbbox%7D%7D%29%3B%0Aout%20center%3B">gleiche Beispiel mit mehr Zeit</a> funktioniert:</p>

<pre>
<codeline>[timeout:90];</codeline>
<codeline>nwr[shop=supermarket]({{bbox}});</codeline>
<codeline>out center;</codeline>
</pre>

<p>Der Server lässt nun eine Abfrage genau dann zu,
wenn sie in beiden Kriterien höchstens die Hälfte der noch verfügbaren Ressourcen belegt.
Für den maximalen Speicherbedarf ist der Wert z.B. 12 GiB.
Wenn also gerade 8 Abfragen zu 512 MiB laufen,
so sind 4 GiB belegt.
Eine weitere Abfrage würde also genau dann zugelassen,
wenn sie weniger als 4 GiB anfordert.
Mit dieser neunten Abfrage zusammen wäre dann noch 4 GiB frei,
so dass dann nur noch eine weitere Abfrage zu weniger als 2 GiB akzeptiert würde.</p>

<p>Bei der Laufzeit verhält es sich entsprechend.
Der übliche Gesamtwert für zulässige Zeiteinheiten sind 262144.
Es wird also eine Abfrage mit Maximallaufzeit 1 Tag recht bequem zugelassen,
aber jede weitere parallele Abfrage mit einer so langen Maximallaufzeit dann abgelehnt.
Der Rate-Limit-Mechanismus sorgt dann mit der anschließenden Beruhigungszeit in der Größenordnung von Tagen dafür,
dass nicht immer derselbe Nutzer von einer so langen Maximallaufzeit profitiert.</p>

<p>Die Last aus Sicht des Servers wird per Munin angezeigt,
<a target="_blank" rel="noopener" href="https://z.overpass-api.de/munin/localdomain/localhost.localdomain/index.html#other">hier</a> und <a target="_blank" rel="noopener" href="https://lz4.overpass-api.de/munin/localdomain/localhost.localdomain/index.html#other">hier</a>.</p>

<p>Wie beim Rate-Limit lehnt der Server zu große Abfragen nicht sofort ab,
sondern wartet 15 Sekunden,
ob nicht in der Zwischenzeit genügend andere Abfragen beendet worden sind.</p>

<p>Wegen unzureichender Ressourcen abgelehnte Abfragen werden mit dem <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7231#section-6.6.5">HTTP-Statuscode 504</a> beantwortet.</p>
<hr/>
<p>weiter: <a href="../targets/index.html">Verwendung</a></p>

</body>
</html>
