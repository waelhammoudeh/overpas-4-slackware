<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
pre { background-color:#ccffff; padding: 0.5em; counter-reset: line; }
div[type=sibling] { text-indent:1em; }
codeline::before { counter-increment: line; content: counter(line)" "; color: #99cccc; }
</style>
  <title>Modèle d'exécution</title>
</head>
<body style="font-family:sans-serif; max-width:32em">

<p><a href="../index.html">Mode d'emploi d'API Overpass</a>  </p>

<nav>
<div type="parent"><strong><a href="index.html">Introduction</a></strong></div>

<div type="sibling"><a href="preface.html">OpenStreetMap et l'API Overpass</a></div>
<div type="sibling"><a href="osm_data_model.html">Modèle de données d'OpenStreetMap</a></div>
<div type="sibling"><a href="glossary.html">Glossaire</a></div>
<div type="sibling"><strong> Modèle d'exécution</strong></div>
<div type="sibling"><a href="assertions.html">Principes</a></div>
<div type="sibling"><a href="commons.html">Mutualisation</a></div>

</nav>
<div type="parent"><a href="../targets/index.html">Utilisation</a></div>
<div type="parent"><a href="../full_data/index.html">Toutes les données dans une région</a></div>
<div type="parent"><a href="../criteria/index.html">Trouver des objets</a></div>
<div type="parent"><a href="../counting/index.html">Compter d'objets</a></div>
<div type="parent"><a href="../analysis/index.html">Analyser des données</a></div>
<div type="parent"><a href="../more_info/index.html">Plus d'informations</a></div>

<hr />

<h1>Modèle d'exécution</h1>

<p>Selon quelles règles l'API Overpass exécute-t-elle une requête?
La présentation des différents éléments constitutifs favorise la compréhension,
comment ils interagissent dans les requêtes.</p>

<nav>
<h3>Sommaire</h3>

<div type="subsection"><a href="design.html#sequential">Séquences</a></div>
<div type="subsection"><a href="design.html#statements">Instructions et filtres </a></div>
<div type="subsection"><a href="design.html#block_statements">Instructions de bloc</a></div>
<div type="subsection"><a href="design.html#evaluators"> Évaluations et éléments dérivées</a></div>
<div type="subsection"><a href="design.html#sets">Plusieurs sélections en parallèle</a></div>

</nav>

<p><a name="sequential"/></p>

<h2>Séquences</h2>

<p>La plupart des cas d'utilisation de requêtes avancées nécessitent des sélections relatives.
Les supermarchés qui sont près d'une gare en sont un bon exemple.
Les supermarchés ne sont reliés aux gares que par cette qualité,
qu'ils sont spatialement proches l'un de l'autre.</p>

<p>D'après le tour de phrase, on cherche d'abord les supermarchés,
puis cherchez dans tous les supermarchés les gares ferroviaires à proximité
et ne garder que les supermarchés où nous avons trouvé une gare.
Cette approche conduit rapidement à des monstruosités relatives en langage naturel;
même en langage formel, cela ne s'améliore pas.</p>

<p>Par conséquent, le langage de requête de l'API Ovepass suit plutôt un paradigme pas a pas,
de la soi-disant <em>programmation impérative</em>.
Une seule tâche gérable est résolue à la fois,
et maîtrisé la tâche complexe en les enchaînant.
L'approche est alors la suivante:</p>

<ul>
<li>Sélectionner toutes les stations dans la zone cible</li>
<li>Remplacez la sélection par tous les supermarchés situés à proximité de ces gares.</li>
<li>Retournez la liste des supermarchés</li>
</ul>

<p>Il en résulte la requête suivante ligne par ligne.
Vous pouvez maintenant l'<a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=13&amp;Q=nwr%5Bpublic_transport%3Dstation%5D%28%7B%7Bbbox%7D%7D%29%3B%0Anwr%5Bshop%3Dsupermarket%5D%28around%3A100%29%3B%0Aout%20center%3B">exécuter</a>:</p>

<pre>
<codeline>nwr[public_transport=station]({{bbox}});</codeline>
<codeline>nwr[shop=supermarket](around:100);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Les détails de la syntaxe seront expliqués plus loin.</p>

<p>Pour des cas plus simples, vous pourriez vouloir une syntaxe encore plus simple,
mais la solution à deux lignes qui en résulte reflète la répartition claire des tâches:</p>

<pre>
<codeline>nwr[shop=supermarket]({{bbox}});</codeline>
<codeline>out center;</codeline>
</pre>

<ul>
<li>L'instruction ou les instructions de sélection déterminent <em>ce qui</em> est édité.</li>
<li>L'instruction <em>out</em> détermine <em>comment</em> les objets sélectionnés sont édités. Détails à propos <a href="../targets/formats.html#faithful">les formats de sortie</a></li>
</ul>

<p><a name="statements"/></p>

<h2>Instructions et filtres</h2>

<p>Nous comparons la requête pour les supermarchés uniquement dans la zone de visibilité</p>

<pre>
<codeline>nwr[shop=supermarket]({{bbox}});</codeline>
<codeline>out center;</codeline>
</pre>

<p>avec la requête ci-dessus</p>

<pre>
<codeline>nwr[public_transport=station]({{bbox}});</codeline>
<codeline>nwr[shop=supermarket](around:100);</codeline>
<codeline>out center;</codeline>
</pre>

<p>pour identifier les composants individuels.</p>

<p>Le caractère le plus important est le point-virgule; il termine une <em>instruction</em> à la fois.
Les sauts de ligne, les espaces (et les tabulations) ne sont pas pertinents pour ceci et pour la syntaxe dans son ensemble.
Ces <em>instructions</em> sont exécutés l'un après l'autre dans l'ordre,
où ils sont écrits.
Ainsi, dans les deux requêtes, il y a quatre instructions ensemble:</p>

<ul>
<li><code>nwr[shop=supermarket]({{bbox}});</code></li>
<li><code>nwr[public_transport=station]({{bbox}});</code></li>
<li><code>nwr[shop=supermarket](around:100);</code></li>
<li><code>out center;</code></li>
</ul>

<p>L'instruction <code>out center</code> est une instruction de sortie sans autres sous-structures.
Les possibilités de contrôle du format de sortie sont discutées dans la section <a href="../targets/formats.html">Formats de données</a>.</p>

<p>Les <em>instructions</em> restants sont tous des instructions de type <em>query</em>,
c'est-à-dire qu'ils sont utilisés pour sélectionner des objets.
Ceci s'applique à tous les énoncés commençant par <code>nwr</code> et autres mots-clés spéciaux:
les mots-clés <code>node</code>, <code>way</code> et <code>relation</code> chacun respectivement restrictent le résultat à des objets de type nœud, chemin et relation,
mais <code>nwr</code> (acronym de <em>node</em>, <em>way</em>, <em>relation</em>) fournit tous les trois types.
Ils ont plusieurs sous-structures ici:</p>

<ul>
<li><code>[shop=supermarket]</code> et <code>[public_transport=station]</code></li>
<li><code>({{bbox}})</code></li>
<li><code>(around:100)</code></li>
</ul>

<p>Toutes les sous-structures d'une instruction <em>query</em> filtrent les objets à sélectionner
et sont donc appelées <em>filter</em>.
Il est possible de combiner n'importe quel nombre de filtres dans une instruction de type <em>query</em>;
l'instruction sélectionne exactement ces objets,
qui remplissent tous les filtres.
L'ordre des filtres n'a pas d'importance,
car les filtres d'une instruction sont appliqués simultanément.</p>

<p>Alors que <code>[shop=supermarket]</code> et <code>[public_transport=station]</code> permettent tous les objets,
qui ont un qualité précis (supermarchés dans un cas, gares dans l'autre),
<code>({{bbox}}})</code> et <code>(around:100)</code> sont utilisés pour le filtrage spatial.</p>

<p>Le filtre <code>({{bbox}})</code> permet exactement de tels objets,
qui se trouvent en tout ou en partie dans le rectangle englobant.</p>

<p>Le filtre <code>(around:100)</code> marche un peu plus compliqués.
Il a besoin d'un input et accepte exactement tous les objets,
qui ne sont pas à plus de 100 mètres de l'un des objets de input.</p>

<p>C'est là que l'exécution pas à pas prend effet:
Le filtre <code>(around:100)</code> reçoit ici comme input exactement les stations sélectionnées dans la ligne précédente.</p>

<p><a name="block_statements"/></p>

<h2>Instructions de bloc</h2>

<p>Comment réaliser une opération <em>ou</em>?
<a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=14&amp;Q=%28%0A%20%20nwr%5Bpublic%5Ftransport%3Dstation%5D%28%7B%7Bbbox%7D%7D%29%3B%0A%20%20nwr%5Bshop%3Dsupermarket%5D%28%7B%7Bbbox%7D%7D%29%3B%0A%29%3B%0Aout%20center%3B">De cette façon</a>, vous pouvez trouver tous les objets qui sont un supermarché <em>ou</em> une gare:</p>

<pre>
<codeline>(</codeline>
<codeline>  nwr[public_transport=station]({{bbox}});</codeline>
<codeline>  nwr[shop=supermarket]({{bbox}});</codeline>
<codeline>);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Ici, les deux instructions de requête forment un bloc dans une structure plus grande.
La structure indiquée par les crochets s'appelle donc une <em>instruction de bloc</em>.</p>

<p>Cette structure de bloc spéciale s'appelle <em>union</em>,
et il est utilisé pour lier plusieurs instructions de cette façon,
qu'il sélectionne tous les objets
trouvées dans l'une ou plusieurs des instructions du bloc.
Il doit y en avoir au moins une et il peut y avoir un nombre illimité d'instructions dans le bloc.</p>

<p>Il y a de nombreuses autres <em>instructions de bloc</em>:</p>

<ul>
<li>L'instruction <em>difference</em> vous permet de couper une sélection à partir d'une autre.</li>
<li><em>if</em> n'exécute son bloc que si la condition de l'en-tête évalue à <em>vrai</em>.
Un deuxième bloc est également possible;
ceci est exécuté si la condition évalue à <em>fausse</em>.</li>
<li><em>foreach</em> exécute son bloc une fois par objet dans son input.</li>
<li><em>for</em> regroupe d'abord les objets et exécute ensuite son bloc une fois par groupe.</li>
<li><em>complete</em> exécute les tâches d'une boucle <em>while</em>.</li>
<li>Des autres instructions de bloc permettent de récupérer des données supprimées ou obsolètes.</li>
</ul>

<p><a name="evaluators"/></p>

<h2>Évaluations et éléments dérivées</h2>

<p>Ce n'est pas encore expliqué,
comment les conditions peuvent être formulées dans l'instructions de bloc <em>if</em> ou <em>for</em>.</p>

<p>Toutefois, le mécanisme utilisé à cette fin est également utile pour d'autres tâches.
Par exemple, vous pouvez créer une <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=16&amp;Q=%5Bout%3Acsv%28name%29%5D%3B%0Away%5Bhighway%5D%28%7B%7Bbbox%7D%7D%29%3B%0Afor%20%28t%5B%22name%22%5D%29%0A%7B%0A%20%20make%20Saisie%20name%3D%5F%2Eval%3B%0A%20%20out%3B%0A%7D">liste de tous les noms de rues</a> dans une zone.</p>

<pre>
<codeline>[out:csv(name)];</codeline>
<codeline>way[highway]({{bbox}});</codeline>
<codeline>for (t["name"])</codeline>
<codeline>{</codeline>
<codeline>  make Saisie name=_.val;</codeline>
<codeline>  out;</codeline>
<codeline>}</codeline>
</pre>

<p>Les lignes 2 et 6 contiennent les phrases simples <code>way[highway]({{bbox}})</code> et <code>out</code> respectivement.
Avec <code>[out:csv(name)]</code> dans la ligne 1, le format de sortie est contrôlé (<a href="../targets/index.html">voir là</a>).
Les lignes 3, 4 et 7 forment l'instruction de bloc <code>for (t["name"])</code>;
elle doit savoir, selon quel critère elle doit regrouper les objets selectionnés.</p>

<p>L'<em>évaluation</em> <code>t["name"]</code> répond à cette question.
Une <em>évaluation</em> est une expression,
qui est évalués au cours de l'exécution d'une instruction.</p>

<p>C'est une expression qui est évaluée pour chaque élément,
puisque <em>for</em> nécessite des informations par élément.
L'expression <code>t["name"]</code> évalue la valeur de l'attribut avec la clé <em>name</em> d'un objet.
Si l'objet n'a pas d'attribut avec la clé <em>name</em>,
l'expression évalue à une chaîne des caractère vide.</p>

<p>La ligne 5 contient également une évaluation avec <code>_.val</code>.
Ceci permet de générer la valeur à éditer.
L'instruction <em>make</em> crée toujours un seul objet à partir de plusieurs objets potentiels,
la valeur de <code>_.val</code> ne doit donc pas dépendre d'objets individuels.
L'évaluation <code>_.val</code> retourne la valeur de l'expression de la boucle courante dans une boucle,
ici la valeur de l'attribut <em>name</em> de tous les objets pertinents.</p>

<p>Si une valeur indépendante est attendue, mais qu'une valeur dépendante de l'objet est spécifiée,
un message d'erreur s'affiche.
Cela se produit, par exemple, si nous voulions afficher la longueur des routes:
<a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=16&amp;Q=%5Bout%3Acsv%28length%2Cname%29%5D%3B%0Away%5Bhighway%5D%28%7B%7Bbbox%7D%7D%29%3B%0Afor%20%28t%5B%22name%22%5D%29%0A%7B%0A%20%20make%20Saisie%20name%3D%5F%2Eval%2Clength%3Dlength%28%29%3B%0A%20%20out%3B%0A%7D">Essayez-le</a>, s'il vous plaît:</p>

<pre>
<codeline>[out:csv(length,name)];</codeline>
<codeline>way[highway]({{bbox}});</codeline>
<codeline>for (t["name"])</codeline>
<codeline>{</codeline>
<codeline>  make Saisie name=_.val,length=length();</codeline>
<codeline>  out;</codeline>
<codeline>}</codeline>
</pre>

<p>Les différents segments d'une rue portant le même nom peuvent avoir des longueurs différentes.
Nous pouvons résoudre ce problème en spécifiant comment les objets doivent être regroupés.
Souvent, on veut <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=16&amp;Q=%5Bout%3Acsv%28length%2Cname%29%5D%3B%0Away%5Bhighway%5D%28%7B%7Bbbox%7D%7D%29%3B%0Afor%20%28t%5B%22name%22%5D%29%0A%7B%0A%20%20make%20Saisie%20name%3D%5F%2Eval%2Clength%3Dset%28length%28%29%29%3B%0A%20%20out%3B%0A%7D">une liste</a>:</p>

<pre>
<codeline>[out:csv(length,name)];</codeline>
<codeline>way[highway]({{bbox}});</codeline>
<codeline>for (t["name"])</codeline>
<codeline>{</codeline>
<codeline>  make Saisie name=_.val,length=set(length());</codeline>
<codeline>  out;</codeline>
<codeline>}</codeline>
</pre>

<p>Dans ce cas particulier, cependant, <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=16&amp;Q=%5Bout%3Acsv%28length%2Cname%29%5D%3B%0Away%5Bhighway%5D%28%7B%7Bbbox%7D%7D%29%3B%0Afor%20%28t%5B%22name%22%5D%29%0A%7B%0A%20%20make%20Saisie%20name%3D%5F%2Eval%2Clength%3Dsum%28length%28%29%29%3B%0A%20%20out%3B%0A%7D">la sommation</a> est probablement plus utile:</p>

<pre>
<codeline>[out:csv(length,name)];</codeline>
<codeline>way[highway]({{bbox}});</codeline>
<codeline>for (t["name"])</codeline>
<codeline>{</codeline>
<codeline>  make Saisie name=_.val,length=sum(length());</codeline>
<codeline>  out;</codeline>
<codeline>}</codeline>
</pre>

<p>L'instruction <em>make</em> crée toujours exactement un nouvel objet, appelé <em>dérivée</em>.
Pourquoi un objet, pourquoi pas juste un objet OpenStreetMap?
Les raisons varient d'un cas d'utilisation à l'autre:
ici, nous avons besoin de quelque chose que nous pouvons retourner.
Dans d'autres cas, on souhaite modifier et supprimer les attributs des objets OpenStreetMap,
ou simplifier la géométrie de l'objet OpenStreetMap,
ou a besoin d'un transporteur pour des informations spéciales.</p>

<p>Les objets OpenStreetMap apparents doivent suivre les règles des objets OpenStreetMap
et ne permettent donc pas beaucoup de libertés utiles.
Surtout, ils pourraient être confondus avec de vrais objets OpenStreetMap
et re-téléchargés à <em>openstreetmap.org</em> par erreur.</p>

<p>Vous pouvez voir les objets générés si vous laissez la requête <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=16&amp;Q=way%5Bhighway%5D%28%7B%7Bbbox%7D%7D%29%3B%0Afor%20%28t%5B%22name%22%5D%29%0A%7B%0A%20%20make%20Saisie%20name%3D%5F%2Eval%2Clength%3Dsum%28length%28%29%29%3B%0A%20%20out%3B%0A%7D">à format de sortie XML</a>:</p>

<pre>
<codeline>way[highway]({{bbox}});</codeline>
<codeline>for (t["name"])</codeline>
<codeline>{</codeline>
<codeline>  make Saisie name=_.val,length=sum(length());</codeline>
<codeline>  out;</codeline>
<codeline>}</codeline>
</pre>

<p><a name="sets"/></p>

<h2>Plusieurs sélections en parallèle</h2>

<p>Dans de nombreux cas, cependant, une seule sélection ne suffit pas.
Par conséquent, les sélections peuvent également être stockées dans des variables nommées
et ainsi garder plusieurs sélections en même temps.</p>

<p>Nous voulons trouver tous les objets d'un même genre,
qui ne sont pas près d'objets de l'autre genre.
Des exemples plus proches à la quotidienne sont souvent la recherche d'erreurs,
p. ex. quais sans voies ou adresses sans rues.
Mais nous n'aborderons pas les subtilités de les attributs maintenant.</p>

<p>Nous enquêtons donc sur tous les supermarchés,
qui <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.4775&amp;lon=0.0&amp;zoom=14&amp;Q=nwr%5Bpublic%5Ftransport%3Dstation%5D%28%7B%7Bbbox%7D%7D%29%2D%3E%2Eall%5Fstations%3B%0A%28%0A%20%20nwr%5Bshop%3Dsupermarket%5D%28%7B%7Bbbox%7D%7D%29%3B%0A%20%20%2D%20nwr%2E%5F%28around%2Eall%5Fstations%3A300%29%3B%0A%29%3B%0Aout%20center%3B">ne sont pas près</a> des gares:</p>

<pre>
<codeline>nwr[public_transport=station]({{bbox}})-&gt;.all_stations;</codeline>
<codeline>(</codeline>
<codeline>  nwr[shop=supermarket]({{bbox}});</codeline>
<codeline>  - nwr._(around.all_stations:300);</codeline>
<codeline>);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Par la ligne 3, la mention <code>nwr[shop=supermarket]({{bbox}})</code> sélectionne tous les supermarchés dans le rectangle englobant.
Nous voulons supprimer un sous-ensemble et donc utiliser une instruction de bloc de type <em>difference</em>;
Les trois éléments <code>(</code> à la ligne 2, <code>-</code> à la ligne 4 et <code>)</code> à la ligne 5 permettent de le reconnaître.</p>

<p>Nous devons choisir des supermarchés près des gares.
Pour ce faire, nous devons choisir les stations comme ci-dessus;
mais nous avons aussi besoin de tous les supermarchés comme sélection.
C'est pourquoi nous guidons la sélection des stations par la <em>variable d'ensemble</em> <code>all_stations</code>.
Dans la ligne 1, la sélection passe d'une instruction ordinaire <code>nwr[public_transport=station]({{bbox}})</code> à cette variable en utilisant la syntaxe <code>-&gt;.all_stations</code>.
L'ajout <code>.all_stations</code> dans <code>(around.all_stations:300)</code> le fera,
que cette variable est utilisée comme source au lieu de la dernière sélection.</p>

<p>Cela ferait <code>nwr[shop=supermarket]({{bbox}})(around.all_stations:300)</code> la bonne instruction,
pour appeler les supermarchés exacts à retirer.
Pour raccourcir la durée d'exécution, nous préférons utiliser la sélection de l'instruction précédente à la ligne 3 - c'est exactement là où se trouvent les supermarchés dans la zone de délimitation.
Ceci se fait au moyen de la <em>filtre</em> <code>._</code>.
Il limite la sélection à de tels résultats,
qui sont dans l'entrée au début de l'instruction.
Depuis que nous avons utilisé l'entrée standard ici,
nous les appelons par leur nom <code>._</code> (trait de soulignement simple).</p>

<p>Le déroulement du processus avec le flux de données en détail:</p>

<ul>
<li>Avant le début de l'exécution, toutes les sélections sont vides.</li>
<li>La ligne 1 est exécutée en premier.
En raison de <code>-&gt;.all_stations</code>, toutes les stations sont alors sélectionnées dans <code>.all_stations</code>;
la sélection standard, en revanche, reste vide.</li>
<li>Les lignes 2 à 5 sont une instruction de type <em>difference</em>,
et cette première exécute son bloc d'instruction.
Par conséquent, la ligne 3 suivante est <code>nwr[shop=supermarket]({{bbox}})</code>.
La ligne 3 n'a pas de redirection,
pour que tous les supermarchés soient ensuite sélectionnés dans la sélection standard.
La sélection <code>all_stations</code> n'est pas mentionnée et est donc conservée.</li>
<li>L'instruction de bloc <em>difference</em> stocke le résultat de son premier opérande,
de la ligne 3.</li>
<li>Ligne 4 utilise la sélection standard via <code>._</code> comme restriction pour son résultat,
et en plus la sélection <code>all_stations</code> est utilisée comme source pour la recherche <em>around</em> via <code>(around.all_stations:300)</code>.
Le résultat est la nouvelle sélection standard et remplace donc la sélection standard précédente.
La sélection <code>all_stations</code> reste inchangée.</li>
<li>L'instruction de bloc <em>difference</em> stocke le résultat de son deuxième opérande,
de la ligne 4.</li>
<li>L'instruction de bloc <em>difference</em> forme maintenant la différence entre les deux résultats tapés.
Comme rien d'autre n'est nécessaire, le résultat devient la nouvelle sélection par défaut.
La sélection <code>all_stations</code> reste inchangée.</li>
<li>Enfin, la ligne 5 est exécutée.
Sans spécification spéciale, <code>out</code> utilise la sélection par défaut comme source.</li>
</ul>

<!-- Traduit avec www.DeepL.com/Translator, partiellement redigé -->
<hr/>
<p>prochaine: <a href="assertions.html">Principes</a></p>

</body>
</html>
