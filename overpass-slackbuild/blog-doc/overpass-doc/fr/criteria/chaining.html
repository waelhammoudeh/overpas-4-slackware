<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
pre { background-color:#ccffff; padding: 0.5em; counter-reset: line; }
div[type=sibling] { text-indent:1em; }
codeline::before { counter-increment: line; content: counter(line)" "; color: #99cccc; }
</style>
  <title>Enchainer</title>
</head>
<body style="font-family:sans-serif; max-width:32em">

<p><a href="../index.html">Mode d'emploi d'API Overpass</a>  </p>

<nav>
<div type="parent"><a href="../preface/index.html">Introduction</a></div>
<div type="parent"><a href="../targets/index.html">Utilisation</a></div>
<div type="parent"><a href="../full_data/index.html">Toutes les données dans une région</a></div>
<div type="parent"><strong><a href="index.html">Trouver des objets</a></strong></div>

<div type="sibling"><a href="nominatim.html">Alternatives</a></div>
<div type="sibling"><a href="per_tag.html">Par Tag</a></div>
<div type="sibling"><strong> Enchainer</strong></div>
<div type="sibling"><a href="union.html">Opérations ET et OU</a></div>
<div type="sibling"><a href="lrs.html">Listes de point-vergule</a></div>
<div type="sibling"><a href="misc_criteria.html">Plus des criterions</a></div>

</nav>
<div type="parent"><a href="../counting/index.html">Compter d'objets</a></div>
<div type="parent"><a href="../analysis/index.html">Analyser des données</a></div>
<div type="parent"><a href="../more_info/index.html">Plus d'informations</a></div>

<hr />

<h1>Enchainer</h1>

<p>Comment on peut enchainer plusieures instructions de manière à pouvoir 
requêter par des critères relatifs à d'autres objets.</p>

<nav>
<h3>Sommaire</h3>

<div type="subsection"><a href="chaining.html#lateral">Filtres indirects</a></div>
<div type="subsection"><a href="chaining.html#topdown">Objets empruntés</a></div>
<div type="subsection"><a href="chaining.html#difference">Différence</a></div>
<div type="subsection"><a href="chaining.html#equality">Attributs à même valeur</a></div>

</nav>

<p><a name="lateral"/></p>

<h2>Filtres indirects</h2>

<p>Nous avons déjà vu des exemples de filtres indirects dans <a href="../full_data/area.html">Requêter par surface</a> et <a href="../full_data/polygon.html">Polygone et autour</a>.
Les objets peuvent également <a href="../preface/design.html#sequential">être référencés en les enchaînant</a>,
qui ne sont même pas inclus dans le résultat final.</p>

<p>Prenons l'exemple,
pour trouver tous les <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=50.95&amp;lon=6.95&amp;zoom=10&amp;Q=area%5Bname%3D%22K%C3%B6ln%22%5D%3B%0Anwr%5Bamenity%3Dcafe%5D%28area%29%3B%0Aout%20center%3B">cafés de Cologne</a>:</p>

<pre>
<codeline>area[name="Köln"];</codeline>
<codeline>nwr[amenity=cafe](area);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Le filtre <code>(area)</code> de la ligne 2 est ici central.
Le filtre filtre par la surface ou les surfaces,
qu'il trouve dans l'ensemble <code>_</code>.
Il fonctionne en commun avec le filtre <code>[amenity=cafe]</code>,
c'est-à-dire que nous recherchons tous les objets dans la ligne 2,
qui sont des <em>nœuds</em>, des <em>chemins</em> ou des <em>relations</em> (<em>nwr</em>)
et qui ont l'attribut <code>amenity</code> avec la valeur <code>cafe</code>
et se trouvent dans les surfaces déposées en <code>_</code>.</p>

<p>Ainsi nous pouvons reformuler la requête ci-dessus et obtenir exactement le même résultat :
<!-- NO_QL_LINK --></p>

<pre>
<codeline>area[name="Köln"];</codeline>
<codeline>nwr[amenity=cafe](area._);</codeline>
<codeline>out center;</codeline>
</pre>

<p>et
<!-- NO_QL_LINK --></p>

<pre>
<codeline>area[name="Köln"]-&gt;._;</codeline>
<codeline>nwr[amenity=cafe](area);</codeline>
<codeline>out center;</codeline>
</pre>

<p>et
<!-- NO_QL_LINK --></p>

<pre>
<codeline>area[name="Köln"]-&gt;._;</codeline>
<codeline>nwr[amenity=cafe](area._);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Dans tous les cas, la surface de la ligne 1 à la ligne 2 est médiée par l'ensemble <code>_</code>.
Les ensembles sont présentés <a href="../preface/design.html#sets">dans une section de l'introduction</a>.</p>

<p>Nous pouvons également utiliser un ensemble <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=50.95&amp;lon=6.95&amp;zoom=10&amp;Q=area%5Bname%3D%22K%C3%B6ln%22%5D%2D%3E%2Enomextremementlong%3B%0Anwr%5Bamenity%3Dcafe%5D%28area%2Enomextremementlong%29%3B%0Aout%20center%3B">avec n'importe quel nom</a>:</p>

<pre>
<codeline>area[name="Köln"]-&gt;.nomextremementlong;</codeline>
<codeline>nwr[amenity=cafe](area.nomextremementlong);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Mais ça ne marche pas,
si le nom des ensembles des deux lignes ne correspond pas :
<!-- NO_QL_LINK --></p>

<pre>
<codeline>area[name="Köln"]-&gt;.nomextremementlong;</codeline>
<codeline>nwr[amenity=cafe](area.nomextrementlong);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Les noms pour les ensembles alors deviennent utiles,
si vous voulez contrôler plusieurs filtres.
Par exemple, nous pouvons chercher des cafés à <em>Münster</em>,
mais l'API Overpass ne le sait pas,
de quelle <em>Münster</em> nous parlons,
parce qu'il y a beaucoup d'endroits plus petits avec le nom en plus de la grande ville
et <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=50.0&amp;lon=10.0&amp;zoom=4&amp;Q=area%5Bname%3D%22M%C3%BCnster%22%5D%3B%0Anwr%5Bamenity%3Dcafe%5D%28area%29%3B%0Aout%20center%3B">il y a là aussi des cafés</a>:</p>

<pre>
<codeline>area[name="Münster"];</codeline>
<codeline>nwr[amenity=cafe](area);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Mais nous pouvons exiger
que le café doit <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=52.0&amp;lon=7.5&amp;zoom=6&amp;Q=area%5Bname%3D%22Nordrhein%2DWestfalen%22%5D%2D%3E%2Ea%3B%0Aarea%5Bname%3D%22M%C3%BCnster%22%5D%2D%3E%2Eb%3B%0Anwr%5Bamenity%3Dcafe%5D%28area%2Ea%29%28area%2Eb%29%3B%0Aout%20center%3B">être situé à la fois</a> à <em>Münster</em> et en <em>Rhénanie-du-Nord-Westphalie</em>:</p>

<pre>
<codeline>area[name="Nordrhein-Westfalen"]-&gt;.a;</codeline>
<codeline>area[name="Münster"]-&gt;.b;</codeline>
<codeline>nwr[amenity=cafe](area.a)(area.b);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Les cafés sont sélectionnés à la ligne 3:
Nous sélectionnons les objets de type <em>node</em>, <em>way</em> ou <em>relation</em>,
qui portent l'attribut <code>amenity=cafe</code>
et qui sont situées à la fois dans l'une des surfaces stockées en <code>a</code> (1 seule zone, à savoir le Land de Rhénanie-du-Nord-Westphalie <code>Nordrhein-Westfalen</code>)
ainsi que dans l'une des zones stockées en <code>b</code> (toutes les villes, districts et villages du nom de <em>Münster</em>).
Ce ne sont que les cafés de <em>Münster</em> en Westphalie.</p>

<p>L'interaction entre plusieurs filtres et la concaténation est approfondie dans <a href="union.html#full">la section suivante</a>.</p>

<p>Par souci d'exhaustivité, nous le soulignons,
que le principe des filtres indirects existe pour tous les types.
Nous voulons trouver tous les ponts sur la rivière <em>Alster</em>.</p>

<p>Nous pouvons trouver la rivière <em>Alster</em> de deux façons différentes,
d'abord <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=53.65&amp;lon=10.1&amp;zoom=10&amp;Q=way%5Bname%3D%22Alster%22%5D%5Bwaterway%3Driver%5D%3B%0Aout%20geom%3B">par le chemin</a>:</p>

<pre>
<codeline>way[name="Alster"][waterway=river];</codeline>
<codeline>out geom;</codeline>
</pre>

<p>Nous cherchons tous les objets de type <em>way</em>,
qui ont l'attribut <code>name</code> avec la valeur <code>Alster</code> et l'attribut <code>waterway</code> avec la valeur <code>river</code>.
Celles-ci sont situées après la ligne 1 dans l'ensemble <code>_</code> et sont éditées à partir de là dans la ligne 2.</p>

<p>Nous trouvons les ponts au lieu de la rivière <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=53.65&amp;lon=10.1&amp;zoom=10&amp;Q=way%5Bname%3D%22Alster%22%5D%5Bwaterway%3Driver%5D%3B%0Away%28around%3A0%29%5Bbridge%3Dyes%5D%3B%0Aout%20geom%3B">comme suit</a>:</p>

<pre>
<codeline>way[name="Alster"][waterway=river];</codeline>
<codeline>way(around:0)[bridge=yes];</codeline>
<codeline>out geom;</codeline>
</pre>

<p>Ici <code>(around:0)</code> dans la ligne 2 est le filtre indirect.
Dans la ligne 2, nous cherchons toutes les chemins,
qui ont l'attribut <code>bridge</code> avec la valeur <code>yes</code>
et qui ont une distance de 0 aux objets de l'ensemble <code>_</code>.
Nous avons rempli l'ensemble <code>_</code> à la ligne 1 avec les chemins dans le rayon desquelles nous voulons chercher,
toutes les chemins qui ont un attribut <code>name</code> avec la valeur <code>Alster</code> et un attribut <code>waterway</code> avec la valeur <code>river</code>.</p>

<p>Le tout fonctionne aussi <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=53.65&amp;lon=10.1&amp;zoom=10&amp;Q=relation%5Bname%3D%22Alster%22%5D%5Bwaterway%3Driver%5D%3B%0Aout%20geom%3B">avec relations</a> ...</p>

<pre>
<codeline>relation[name="Alster"][waterway=river];</codeline>
<codeline>out geom;</codeline>
</pre>

<p>... donc <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=53.65&amp;lon=10.1&amp;zoom=10&amp;Q=relation%5Bname%3D%22Alster%22%5D%5Bwaterway%3Driver%5D%3B%0Away%28around%3A0%29%5Bbridge%3Dyes%5D%3B%0Aout%20geom%3B">avec des ponts</a>:</p>

<pre>
<codeline>relation[name="Alster"][waterway=river];</codeline>
<codeline>way(around:0)[bridge=yes];</codeline>
<codeline>out geom;</codeline>
</pre>

<p><a name="topdown"/></p>

<h2>Objets empruntés</h2>

<p>Nous avons rencontré une application de concaténation complètement différente dans les sections <a href="../full_data/osm_types.html#rels">Relations</a> et <a href="../full_data/osm_types.html#rels_on_rels">Relations sur relations</a> dans <a href="../full_data/osm_types.html">Géométries</a>:
Parce que le modèle de données OSM traditionnel ne permet que des coordonnées sur les <em>nœuds</em>,
mais aussi la géométrie des autres objets est intéressante,
<em>chemins</em> et <em>relations</em> doivent être complétés par les objets d'aide correspondants dans le modèle de données OSM traditionnel.</p>

<p>Les aspects d'chaînage sont expliqués à l'aide d'un exemple:
Certes la ligne de métro <em>Waterloo &amp; City</em> à Londres peut être obtenue <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=14&amp;Q=rel%5Bref%3D%22Waterloo%20%26%20City%22%5D%3B%0Aout%20geom%3B">comme suit</a>:</p>

<pre>
<codeline>rel[ref="Waterloo &amp; City"];</codeline>
<codeline>out geom;</codeline>
</pre>

<p>Mais nous avons besoin d'un <a href="../targets/formats.html#extras">modèle de données étendu</a>,
que quelques applications ne supportent pas.
Si, en revanche, nous <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=14&amp;Q=rel%5Bref%3D%22Waterloo%20%26%20City%22%5D%3B%0Aout%3B">utilisons</a> le niveau de détail traditionnel <em>out</em> pour la sortie,
nous ne voyons rien:</p>

<pre>
<codeline>rel[ref="Waterloo &amp; City"];</codeline>
<codeline>out;</codeline>
</pre>

<p>La relation est toujours dans l'ensemble <code>_</code> après la sortie de la ligne 2.
Par conséquent, nous pouvons collecter les <em>chemins</em> et les <em>nœuds</em> correspondants,
<a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=14&amp;Q=rel%5Bref%3D%22Waterloo%20%26%20City%22%5D%3B%0Aout%3B%0A%28%0A%20%20way%28r%29%3B%0A%20%20node%28w%29%3B%0A%29%3B%0Aout%20skel%3B">en combinant</a> l'union expliquée <a href="union.html#union">dans la section suivante</a> avec le chaînage:</p>

<pre>
<codeline>rel[ref="Waterloo &amp; City"];</codeline>
<codeline>out;</codeline>
<codeline>(</codeline>
<codeline>  way(r);</codeline>
<codeline>  node(w);</codeline>
<codeline>);</codeline>
<codeline>out skel;</codeline>
</pre>

<p>Avant la ligne 3 l'ensemble <code>_</code> contient les relations trouvées comme indiqué précédemment.
Les lignes 3 à 6 sont l'instruction <a href="union.html#union">union</a>.
La ligne 4 <code>way(r)</code> est donc la ligne suivante après la ligne 2 et obtient les relations en entrée.
Il recherche les <em>chemins</em> qui satisfont le filtre <code>(r)</code>,
c'est-à-dire sont référencés par une ou plusieurs <em>relations</em> dans l'entrée.
Comme résultat, il écrit maintenant ces <em>chemins</em> dans l'ensemble <code>_</code>.
L'instruction <em>union</em> en conserve une copie pour son résultat selon sa sémantique.</p>

<p>La ligne 5 <code>node(w)</code> trouve donc les <em>chemins</em> de la ligne 4 comme entrées dans l'ensemble <code>_</code>.
Il recherche les <em>nœuds</em> qui satisfont le filtre <code>(w)</code>,
c'est-à-dire référencés par une ou plusieurs <em>chemins</em> dans l'entrée.
Comme résultat, il écrit ces <em>chemins</em> dans l'ensemble <code>_</code>,
mais <em>union</em> remplace l'ensemble par son propre résultat de toute façon.</p>

<p>Comme résultat de la ligne 6, l'instruction <em>union</em> écrit l'unification des résultats dans l'ensemble <code>_</code>.
Nous obtenons donc toutes les <em>chemins</em> qui ont été référencés par les relations
et tous les <em>nœuds</em> référencés par ces <em>chemins</em>.</p>

<p>Cependant, les relations peuvent aussi avoir des <em>nœuds</em> directement en tant que membres,
et ces relations ont réellement;
vous pouvez le voir dans <a href="../targets/turbo.html#basics">l'onglet de données</a> ou <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=14&amp;Q=rel%5Bref%3D%22Waterloo%20%26%20City%22%5D%3B%0Anode%28r%29%3B%0Aout%3B">par requête</a>:</p>

<pre>
<codeline>rel[ref="Waterloo &amp; City"];</codeline>
<codeline>node(r);</codeline>
<codeline>out;</codeline>
</pre>

<p>On remplace ainsi les <em>relations</em> de la ligne 2 de l'ensemble <code>_</code> par les <em>nœuds</em> référencés.
Ensuite, nous avons ces <em>nœuds</em> disponibles pour la sortie de la ligne 3,
mais ils auraient à nouveau besoin de ces <em>relations</em>,
pour obtenir les <em>chemins</em> référencés.
Peut-on éviter la double recherche?</p>

<p>Oui, <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=14&amp;Q=rel%5Bref%3D%22Waterloo%20%26%20City%22%5D%3B%0Aout%3B%0A%28%0A%20%20node%28r%29%2D%3E%2Edirectement%5Freferences%5Fpar%5Fles%5Frelations%3B%0A%20%20way%28r%29%3B%0A%20%20node%28w%29%3B%0A%29%3B%0Aout%20skel%3B">avec des ensembles nommés</a>:</p>

<pre>
<codeline>rel[ref="Waterloo &amp; City"];</codeline>
<codeline>out;</codeline>
<codeline>(</codeline>
<codeline>  node(r)-&gt;.directement_references_par_les_relations;</codeline>
<codeline>  way(r);</codeline>
<codeline>  node(w);</codeline>
<codeline>);</codeline>
<codeline>out skel;</codeline>
</pre>

<p>En détail:</p>

<ul>
<li>Après la ligne 1, l'ensemble <code>_</code> contient toutes les <em>relations</em>,
qui ont un attribut <code>ref</code> d'une valeur de <code>Waterloo &amp; City</code>.</li>
<li>Celles-ci sont sorties sur la ligne 2.
L'ensemble <code>_</code> contient toujours les relations.</li>
<li>L'instruction de bloc <em>union</em> de la ligne 3 à la ligne 7 exécute le bloc qui s'y trouve.</li>
<li>la ligne 4, <code>(r)</code> utilise donc le contenu d'ensemble <code>_</code>, à savoir les relations de la ligne 1.
Ainsi, ces <em>nœuds</em> sont maintenant stockés dans l'ensemble <code>directement_references_par_les_relations</code>,
qui sont référencées par l'une des relations.
L'instruction <em>union</em> conserve une copie du résultat.
Sinon, le résultat ne nous intéresse pas,
mais voulons seulement empêcher l'instruction d'écraser l'ensemble <code>_</code>.</li>
<li>la ligne 5, <code>(r)</code> utilise à nouveau le contenu d'ensemble <code>_</code>,
et ce sont toujours les <em>relations</em>, parce qu'on ne les a pas écrasées.
L'ensemble <code>_</code> contient maintenant les <em>chemins</em> qui sont référencées par les <em>relations</em>.
L'instruction <em>union</em> conserve une copie du résultat.</li>
<li>la ligne 6, <code>(w)</code> utilise à nouveau le contenu d'ensemble <code>_</code>.
Ce sont maintenant les <em>chemins</em> écrites à la ligne 5.
Les <em>nœuds</em> référencés par ces <em>chemins</em> sont donc maintenant stockés dans l'ensemble <code>_</code>.
L'instruction <em>union</em> conserve une copie du résultat.</li>
<li>L'instruction <em>union</em> compose maintenant le résultat global à partir de ses résultats partiels des lignes 4, 5 et 6
et l'écrire dans l'ensemble <code>_</code>.</li>
<li>L'ensemble <code>_</code> est maintenant sorti sur la ligne 8.</li>
</ul>

<p>Puisqu'il s'agit d'un problème très courant,
il y a <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=14&amp;Q=rel%5Bref%3D%22Waterloo%20%26%20City%22%5D%3B%0Aout%3B%0A%3E%3B%0Aout%20skel%3B">une abréviation pour cette tâche</a>:</p>

<pre>
<codeline>rel[ref="Waterloo &amp; City"];</codeline>
<codeline>out;</codeline>
<codeline>&gt;;</codeline>
<codeline>out skel;</codeline>
</pre>

<p>Les lignes 1 et 2 fonctionnent exactement comme avant,
et la ligne 4 fonctionne exactement comme la ligne 8 avant:
Parce que la flèche de la ligne 3 a une sémantique,
qu'il trouve les <em>chemins</em> et <em>nœuds</em> directement et indirectement référencés aux relations dans l'ensemble <code>_</code>
et le dépenser sur l'ensemble <code>_</code>.</p>

<p>Maintenant, certains programmes sont surtaxés,
si l'ordre dans le fichier n'est pas exactement tous les <em>nœuds</em>, alors tous les <em>chemins</em>, puis toutes les <em>relations</em>.</p>

<p>Pour l'approche détaillée, cet objectif est atteint,
en <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=14&amp;Q=%28%0A%20%20rel%5Bref%3D%22Waterloo%20%26%20City%22%5D%3B%0A%20%20node%28r%29%2D%3E%2Edirekt%5Fvon%5Fden%5Frelations%5Freferenziert%3B%0A%20%20way%28r%29%3B%0A%20%20node%28w%29%3B%0A%29%3B%0Aout%3B">déplaçant</a> la demande initiale vers l'instruction bloc <em>union</em>:</p>

<pre>
<codeline>(</codeline>
<codeline>  rel[ref="Waterloo &amp; City"];</codeline>
<codeline>  node(r)-&gt;.direkt_von_den_relations_referenziert;</codeline>
<codeline>  way(r);</codeline>
<codeline>  node(w);</codeline>
<codeline>);</codeline>
<codeline>out;</codeline>
</pre>

<p>La même chose <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=14&amp;Q=%28%0A%20%20rel%5Bref%3D%22Waterloo%20%26%20City%22%5D%3B%0A%20%20%3E%3B%0A%29%3B%0Aout%3B">avec la flèche</a>:</p>

<pre>
<codeline>(</codeline>
<codeline>  rel[ref="Waterloo &amp; City"];</codeline>
<codeline>  &gt;;</codeline>
<codeline>);</codeline>
<codeline>out;</codeline>
</pre>

<p><a name="difference"/></p>

<h2>Différence</h2>

<p>...
<!--  TODO: Differenz wegen ._-Falle --></p>

<p><a name="equality"/></p>

<h2>Attributs à même valeur</h2>

<p>...
<!-- TODO: Wertgleichheit via Evaluator --></p>
<hr/>
<p>prochaine: <a href="union.html">Opérations ET et OU</a></p>

</body>
</html>
