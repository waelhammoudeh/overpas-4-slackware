<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
pre { background-color:#ccffff; padding: 0.5em; counter-reset: line; }
div[type=sibling] { text-indent:1em; }
codeline::before { counter-increment: line; content: counter(line)" "; color: #99cccc; }
</style>
  <title>Listes de point-vergule</title>
</head>
<body style="font-family:sans-serif; max-width:32em">

<p><a href="../index.html">Mode d'emploi d'API Overpass</a>  </p>

<nav>
<div type="parent"><a href="../preface/index.html">Introduction</a></div>
<div type="parent"><a href="../targets/index.html">Utilisation</a></div>
<div type="parent"><a href="../full_data/index.html">Toutes les données dans une région</a></div>
<div type="parent"><strong><a href="index.html">Trouver des objets</a></strong></div>

<div type="sibling"><a href="nominatim.html">Alternatives</a></div>
<div type="sibling"><a href="per_tag.html">Par Tag</a></div>
<div type="sibling"><a href="chaining.html">Enchainer</a></div>
<div type="sibling"><a href="union.html">Opérations ET et OU</a></div>
<div type="sibling"><strong> Listes de point-vergule</strong></div>
<div type="sibling"><a href="misc_criteria.html">Plus des criterions</a></div>

</nav>
<div type="parent"><a href="../counting/index.html">Compter d'objets</a></div>
<div type="parent"><a href="../analysis/index.html">Analyser des données</a></div>
<div type="parent"><a href="../more_info/index.html">Plus d'informations</a></div>

<hr />

<h1>Listes de point-vergule</h1>

<p>Aides pour traiter des attributs qui ont dans leurs valeurs plusieurs entrées separées par point-vergule.</p>

<nav>
<h3>Sommaire</h3>

<div type="subsection"><a href="lrs.html#intro">Plusieurs valeurs</a></div>
<div type="subsection"><a href="lrs.html#single">Trouver une seule valeur</a></div>
<div type="subsection"><a href="lrs.html#multiple">Trouver plusieures valeurs</a></div>
<div type="subsection"><a href="lrs.html#all">Toutes valeurs</a></div>

</nav>

<p><a name="intro"/></p>

<h2>Plusieurs valeurs</h2>

<p>Dans certains cas, c'est nécessaire,
dans OpenStreetMap pour enregistrer plusieurs <em>valeurs</em> pour une <em>clé</em>.
Les bâtiments à plusieurs niveaux en sont un exemple:
Même si chaque élément n'est généralement situé que sur un seul étage,
le but des escaliers et des ascenseurs est de relier plusieurs étages
et, par conséquent, occuper l'espace sur les deux étages.</p>

<p>Il en va de même pour les routes ou autres voies de circulation,
si l'opérateur a attribué plusieurs numéros à une section.
Cependant, plusieurs numéros de maison <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=0.0&amp;zoom=13&amp;Q=nwr%5B%22addr%3Ahousenumber%22%7E%22%3B%22%5D%28%7B%7Bbbox%7D%7D%29%3B%0Aout%20center%3B">se retrouvent</a> également sur une propriété ou un bâtiment:</p>

<pre>
<codeline>nwr["addr:housenumber"~";"]({{bbox}});</codeline>
<codeline>out center;</codeline>
</pre>

<p>La norme de facto pour les <em>valeurs</em> multiples pour la même <em>clé</em> est de l'utiliser,
pour enchaîner les valeurs ensemble dans la <em>valeur</em>, séparées par des points-virgules.
C'est un problème pour plusieurs raisons:</p>

<p>Premièrement, le point-virgule est un caractère valide dans la <em>valeur</em>,
afin qu'une seule <em>valeur</em> puisse être divisée par erreur,
si le logiciel se divise en points-virgules.
Cela ne doit pas nécessairement se produire dans OSM:
Dans les formats populaires comme le CSV, le point-virgule est souvent utilisé comme séparateur.</p>

<p>Ensuite, la séquence des éléments soulève la question de savoir si l'ordre des éléments joue un rôle.
Avec des exemples tels que les valeurs <code>-2;-1</code> et <code>-1;-2</code> pour l'<em>attribut</em> avec la <em>clé</em> <code>level</code>
la réponse est non.
D'autre part, les clés comme celles des marques maritimes ou des panneaux de randonnée suggèrent
que <code>red;white;blue</code> est différent de <code>blue;red;white</code>.</p>

<p>Mais la stockage de l'ordre prend d'espace:
Même pour 15 choses, l'idéal serait que vous n'ayez besoin que de 2 octets pour stocker la présence,
mais 5 octets pour stocker l'ordre actuelle.</p>

<p>Les autres questions sont:</p>

<ul>
<li>Est-ce que -1 et -1.0 sont les mêmes valeurs?</li>
<li>Qu'en est-il des espaces prealablents ou suivants?</li>
<li>Qu'est-ce que cela signifie quand deux points-virgules se suivent directement?</li>
</ul>

<p>J'ai donc établi une convention pour l'API Overpass,
qui s'harmonise le mieux possible avec l'utilisation actuelle:</p>

<p><em>Toutes les valeurs des balises sont initialement traitées comme un tout et les points-virgules ne sont pas spéciaux,
à moins que la valeur ne soit transmise à une fonction de traitement de point-virgule.
De telles fonctions peuvent ignorer les espaces avant ou arrière.
Si une liste ne contient que des numéros,
peuvent mettre en équation les mêmes nombres et les trier par valeur numérique.</em></p>

<p>Dans les sections suivantes, nous présentons les fonctions à l'aide de problèmes typiques:</p>

<ul>
<li>Comment trouver tous les objets dans lesquels une <em>valeur</em> Y apparaît dans l'<em>attribut</em> à <em>clé</em> X?</li>
<li>Comment trouver tous les objets dans lesquels au moins une de plusieurs <em>valeurs</em> se produit dans l'<em>attribut</em> à <em>clé</em> X?</li>
<li>Comment peut-on énumérer toutes les <em>valeurs</em>?</li>
</ul>

<p>Les fonctions d'analyse des données génèrent parfois des listes séparées par des points-virgules.
Cependant, ceci et la façon de les utiliser seront expliqués là.</p>

<p><a name="single"/></p>

<h2>Trouver une seule valeur</h2>

<p>Nous essayons de nous rendre à l'une des principales stations de métro de Londres (<em>Bank</em> et <em>Monument</em>)
pour trouver tous les escaliers qui touchent le niveau <code>-2</code>.
En cherchant <em>seulement la valeur</em>, on <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.512&amp;lon=-0.0875&amp;zoom=17&amp;Q=way%5Bhighway%3Dsteps%5D%5Blevel%3D%2D2%5D%28%7B%7Bbbox%7D%7D%29%3B%0Aout%20center%3B">ne trouve rien</a>:</p>

<pre>
<codeline>way[highway=steps][level=-2]({{bbox}});</codeline>
<codeline>out center;</codeline>
</pre>

<p>A ce stade, la recherche par expression régulière serait possible.
Mais cela est au mieux extrêmement lourd et ne sera pas discuté en détail ici.
Il faut le souligner,
qu'une telle expression régulière trouve facilement involontairement les valeurs <code>-2.3</code> ou <code>-2.7</code> se produisant ici.</p>

<p>La fonction point-virgule <code>lrs_in</code> <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.512&amp;lon=-0.0875&amp;zoom=17&amp;Q=way%5Bhighway%3Dsteps%5D%28%7B%7Bbbox%7D%7D%29%0A%20%20%28if%3Alrs%5Fin%28%22%2D2%22%2Ct%5B%22level%22%5D%29%29%3B%0Aout%20center%3B">sélectionne</a> exactement les objets qui ont la valeur <code>-2</code> directement ou dans une liste point-virgule:</p>

<pre>
<codeline>way[highway=steps]({{bbox}})</codeline>
<codeline>  (if:lrs_in("-2",t["level"]));</codeline>
<codeline>out center;</codeline>
</pre>

<p>Les objets avec des <em>valeurs</em> comme <code>-2;-1</code> ou <code>-3;-2</code> sont trouvés par la requête ainsi que la <em>valeur</em> <code>-2</code> seule.</p>

<p>En détail:
Les lignes 1 et 2 ensemble sont une instruction de requête avec un total de 3 filtres;
nous sommes intéressés par le filtre <code>(if:lrs_in("-2",t["level"]))</code>.
Ici, <code>(if:...)</code> est d'abord le filtre générique,
qui pour chaque objet en question évalue l'évaluateur à son intérieur;
seuls les objets pour lesquels l'évaluateur évalue à autre chose que <code>0</code>, <code>false</code> ou la valeur vide sont sélectionnés.
Nous examinons les objets avec l'évaluateur <code>lrs_in("-2",t["level"])</code>;
qui à son tour a deux arguments :</p>

<ul>
<li>le premier argument, ici la constante <code>-2</code>, est la valeur à trouver</li>
<li>le second argument, ici <code>t["level"]</code>, est la liste à rechercher</li>
</ul>

<p>Tout compte fait, c'est écrit ici comme une instruction:
Recherchez tous les <em>chemins</em> dans le rectangle englobant (<code>({{bbox}})</code>) avec la <em>valeur</em> <code>steps</code> jusqu'à la clé <code>highway</code>,
qui contiennent la valeur <code>-2</code> dans la liste séparée par un point-virgule comme <em>valeur</em> pour la <em>clé</em> <code>level</code>.</p>

<p>Toutes les fonctions de traitement des points-virgules commencent par le préfixe <code>lrs_</code>;
qui signifie <em>List represented set</em> (ensemble représenté par liste).</p>

<p>Le filtre <code>(if:...)</code>, cependant, est un filtre dit <em>faible</em>.
Il ne peut pas être le seul filtre, car cela nécessiterait l'inspection de tous les objets dans le monde entier.
La tentative suivante de recherche dans le monde entier aboutira donc à <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.512&amp;lon=-0.0875&amp;zoom=17&amp;Q=way%28if%3Alrs%5Fin%28%22%2D2%22%2Ct%5B%22level%22%5D%29%29%3B%0Aout%20center%3B">un message d'erreur</a>:</p>

<pre>
<codeline>way(if:lrs_in("-2",t["level"]));</codeline>
<codeline>out center;</codeline>
</pre>

<p>Pour la plupart des applications, ce n'est pas un problème,
parce qu'un filtre puissant est déjà disponible via le rectangle englobant ou un autre critère spatial.
Dans la plupart des autres cas, le filtre <code>[level]</code> comme filtre après seulement la présence de clé est suffisant.
Pour <code>level</code> en particulier, la procédure n'est pas utile,
en raison de la nombre élevée, il y a encore beaucoup d'objets à contrôler.
La quantité de données est alors finalement un défi pour le navigateur:
<!-- NO_QL_LINK --></p>

<pre>
<codeline>way[level](if:lrs_in("-2",t["level"]));</codeline>
<codeline>out center;</codeline>
</pre>

<p>Pour d'autres attributs, cependant, cela peut être une solution appropriée.</p>

<p>Le nouveau filtre <code>[level]</code> utilisé ici est discuté en détail dans la <a href="misc_criteria.html#per_key">section suivante</a>.</p>

<p>Inversement, si on veut cacher tous les escaliers qui se terminent au niveau -2
alors on <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.512&amp;lon=-0.0875&amp;zoom=17&amp;Q=way%5Bhighway%3Dsteps%5D%28%7B%7Bbbox%7D%7D%29%0A%20%20%28if%3A%21lrs%5Fin%28%22%2D2%22%2Ct%5B%22level%22%5D%29%29%3B%0Aout%20center%3B">peut le faire</a> directement chez l'évaluateur par <code>!</code> pour la négation logique:</p>

<pre>
<codeline>way[highway=steps]({{bbox}})</codeline>
<codeline>  (if:!lrs_in("-2",t["level"]));</codeline>
<codeline>out center;</codeline>
</pre>

<p>Cependant, nous devrions y réfléchir à ce moment-là,
si nous voulons sélectionner des escaliers qui n'ont pas d'attribut <em>level</em> définie.
Seulement les escaliers <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.512&amp;lon=-0.0875&amp;zoom=17&amp;Q=way%5Bhighway%3Dsteps%5D%28%7B%7Bbbox%7D%7D%29%0A%20%20%28if%3A%21lrs%5Fin%28%22%2D2%22%2Ct%5B%22level%22%5D%29%29%0A%20%20%5Blevel%5D%3B%0Aout%20center%3B">avec <code>level</code></a> réglé:</p>

<pre>
<codeline>way[highway=steps]({{bbox}})</codeline>
<codeline>  (if:!lrs_in("-2",t["level"]))</codeline>
<codeline>  [level];</codeline>
<codeline>out center;</codeline>
</pre>

<p><a name="multiple"/></p>

<h2>Trouver plusieures valeurs</h2>

<p>Nous voulons maintenant trouver un restaurant à Londres avec une cuisine typiquement pour cet endroit.
Il n'est pas si évident de savoir si nous devons chercher <code>british</code>, <code>english</code> ou <code>regional</code>.</p>

<p>En principe, nous pourrions résoudre ce problème avec une instruction <em>union</em> sur <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.512&amp;lon=-0.0875&amp;zoom=14&amp;Q=%28%0A%20%20nwr%5Bcuisine%5D%28%7B%7Bbbox%7D%7D%29%0A%20%20%20%20%28if%3Alrs%5Fin%28%22english%22%2Ct%5B%22cuisine%22%5D%29%29%3B%0A%20%20nwr%5Bcuisine%5D%28%7B%7Bbbox%7D%7D%29%0A%20%20%20%20%28if%3Alrs%5Fin%28%22british%22%2Ct%5B%22cuisine%22%5D%29%29%3B%0A%20%20nwr%5Bcuisine%5D%28%7B%7Bbbox%7D%7D%29%0A%20%20%20%20%28if%3Alrs%5Fin%28%22regional%22%2Ct%5B%22cuisine%22%5D%29%29%3B%0A%29%3B%0Aout%20center%3B">toutes les valeurs possibles</a>:</p>

<pre>
<codeline>(</codeline>
<codeline>  nwr[cuisine]({{bbox}})</codeline>
<codeline>    (if:lrs_in("english",t["cuisine"]));</codeline>
<codeline>  nwr[cuisine]({{bbox}})</codeline>
<codeline>    (if:lrs_in("british",t["cuisine"]));</codeline>
<codeline>  nwr[cuisine]({{bbox}})</codeline>
<codeline>    (if:lrs_in("regional",t["cuisine"]));</codeline>
<codeline>);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Ça va vite devenir compliqué,
pour un plus grand nombre de valeurs ainsi que pour d'autres raisons pour un opération OU.</p>

<p>Nous utilisons donc la fonction de traitement des points-virgules <code>lrs_isect</code> (d'<em>intersection</em>),
qui <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.512&amp;lon=-0.0875&amp;zoom=14&amp;Q=nwr%5Bcuisine%5D%28%7B%7Bbbox%7D%7D%29%0A%20%20%20%28if%3Alrs%5Fisect%28t%5B%22cuisine%22%5D%2C%22english%3Bbritish%3Bregional%22%29%29%3B%0Aout%20center%3B">trouve</a> les valeurs communes de deux listes de points-virgules:</p>

<pre>
<codeline>nwr[cuisine]({{bbox}})</codeline>
<codeline>   (if:lrs_isect(t["cuisine"],"english;british;regional"));</codeline>
<codeline>out center;</codeline>
</pre>

<p>Le filtre  <code>(if:lrs_isect(t["cuisine"],"english;british;regional")</code> dans la ligne 2 est le filtre intéressant de la requête:
Là, <code>(if:...)</code> évalue chaque élément,
si une valeur différente de <code>0</code>, <code>false</code> et la valeur vide est déterminée.
L'évaluateur <code>lrs_isect(t["cuisine"],"english;british;regional")</code> a, encore une fois, deux arguments,
qu'il considère comme des listes
(une liste sans point-virgule est une liste avec la valeur comme seule entrée).
Il retourne les entrées qui apparaissent dans les deux listes;
c'est-à-dire une valeur non vide exactement à ce moment-là,
si au moins une des valeurs <code>english</code>, <code>british</code> ou <code>regional</code> apparaît dans la valeur à le clé <code>cuisine</code>.</p>

<p>Un requête complet est créée en limitant les objets à sélectionner, ainsi que les filtres sur le rectangle englobante et le filtre sur la clé <code>cuisine</code>.
Dans la ligne 3, la sélection est sortie.</p>

<p>De plus, <code>lrs_isect</code> peut être mis à la négative pour obtenir une logique vraie exactement à ce moment-là,
si <code>lrs_isect</code> a livré une liste vide.</p>

<p>A des fins d'illustration, nous présentons sous forme de tableau <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.512&amp;lon=-0.0875&amp;zoom=14&amp;Q=%5Bout%3Acsv%28cuisine%2C%20isect%2C%20negated%29%5D%3B%0Anwr%5Bcuisine%5D%28%7B%7Bbbox%7D%7D%29%3B%0Afor%20%28t%5B%22cuisine%22%5D%29%0A%7B%0A%20%20make%20info%20cuisine%3D%5F%2Eval%2C%0A%20%20%20%20isect%3D%22%7B%22%2Blrs%5Fisect%28%5F%2Eval%2C%22english%3Bbritish%3Bregional%22%29%2B%22%7D%22%2C%0A%20%20%20%20negated%3D%22%7B%22%2B%21lrs%5Fisect%28%5F%2Eval%2C%22english%3Bbritish%3Bregional%22%29%2B%22%7D%22%3B%0A%20%20out%3B%0A%7D">toutes les valeurs qui se produisent ici</a>:</p>

<pre>
<codeline>[out:csv(cuisine, isect, negated)];</codeline>
<codeline>nwr[cuisine]({{bbox}});</codeline>
<codeline>for (t["cuisine"])</codeline>
<codeline>{</codeline>
<codeline>  make info cuisine=_.val,</codeline>
<codeline>    isect="{"+lrs_isect(_.val,"english;british;regional")+"}",</codeline>
<codeline>    negated="{"+!lrs_isect(_.val,"english;british;regional")+"}";</codeline>
<codeline>  out;</codeline>
<codeline>}</codeline>
</pre>

<p>Les détails de la syntaxe sont expliqués dans le chapitre <a href="../analysis/index.html">Analyser des données</a>.
La colonne <code>cuisine</code> contient la valeur respective de l'attribut <em>cuisine</em>.
La colonne <code>isect</code> contient ce que <code>lrs_isect(_.val,"english;british;regional")</code> en fait.
Pour les valeurs non vides, il faut faire défiler un peu,
mais au plus tard avec les entrées commençant par <code>british</code> il y en a.
La colonne <code>negated</code> contient ce que l'opérateur de négation <code>!</code> fait avec l'entrée correspondante pour <code>isect</code>.
L'entrée vide renvoie <code>1</code>, une entrée pleine renvoie <code>0</code>.</p>

<p><a name="all"/></p>

<h2>Toutes valeurs</h2>

<p>...</p>
<hr/>
<p>prochaine: <a href="misc_criteria.html">Plus des criterions</a></p>

</body>
</html>
