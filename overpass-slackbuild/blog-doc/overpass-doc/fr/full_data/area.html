<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
pre { background-color:#ccffff; padding: 0.5em; counter-reset: line; }
div[type=sibling] { text-indent:1em; }
codeline::before { counter-increment: line; content: counter(line)" "; color: #99cccc; }
</style>
  <title>Requêter par surface</title>
</head>
<body style="font-family:sans-serif; max-width:32em">

<p><a href="../index.html">Mode d'emploi d'API Overpass</a>  </p>

<nav>
<div type="parent"><a href="../preface/index.html">Introduction</a></div>
<div type="parent"><a href="../targets/index.html">Utilisation</a></div>
<div type="parent"><strong><a href="index.html">Toutes les données dans une région</a></strong></div>

<div type="sibling"><a href="bbox.html">Rectangle englobant</a></div>
<div type="sibling"><a href="osm_types.html">Des géométries</a></div>
<div type="sibling"><a href="map_apis.html">Autres APIs disponibles</a></div>
<div type="sibling"><a href="polygon.html">Polygone et autour</a></div>
<div type="sibling"><strong> Requêter par surface</strong></div>
<div type="sibling"><a href="other_sources.html">Alternatives</a></div>

</nav>
<div type="parent"><a href="../criteria/index.html">Trouver des objets</a></div>
<div type="parent"><a href="../counting/index.html">Compter d'objets</a></div>
<div type="parent"><a href="../analysis/index.html">Analyser des données</a></div>
<div type="parent"><a href="../more_info/index.html">Plus d'informations</a></div>

<hr />

<h1>Requêter par surface</h1>

<p>Toutes donées dans un region nommé comme un ville ou un département.</p>

<nav>
<h3>Sommaire</h3>

<div type="subsection"><a href="area.html#deprecation">Avertissement au futur</a></div>
<div type="subsection"><a href="area.html#per_tag">Par nom ou par attribut</a></div>
<div type="subsection"><a href="area.html#full">Véritablement tous</a></div>
<div type="subsection"><a href="area.html#combining">Surface dans surface</a></div>
<div type="subsection"><a href="area.html#background">Contexte technique</a></div>

</nav>

<p><a name="deprecation"/></p>

<h2>Avertissement au futur</h2>

<p>Le contenu de ce manuel est revendiqué comme suit,
qu'elles s'appliqueront encore dans de nombreuses années à venir.
Cela ne s'applique pas nécessairement au concept actuel de <em>surfaces</em>:
Le type de données a été créé pour rester compatible,
si un type de données pour les surfaces est ajouté au modèle de données OpenStreetMap.
En attendant, je suis sûr que ça n'arrivera plus.</p>

<p>C'est pourquoi je planifie maintenant,
d'offrir des surfaces directement à partir des types établis <em>chemin fermé</em> et <em>relation</em>.
La planification et la mise en œuvre concrètes prendront certainement des années.
Cependant, à la fin de ce processus, certaines des variantes syntaxiques énumérées ici seront probablement dépassées.
Dans le cadre de la <a href="../preface/assertions.html#infrastructure">rétrocompatibilité</a>, aussi peu de requêtes que possible seront déclarées obsolètes.</p>

<p>Actuellement, c'est l'intention,
que <em>area</em> est alors utilisé comme synonyme de <em>chemin</em> plus <em>relation</em> plus un évaluateur <code>is_closed()</code>.
Inversement, <code>is_in</code> trouvera probablement ces types de données;
il sera logique de remplacer cette <em>instruction</em> par un filtre.</p>

<p>Inversement, je vous demande de ne pas vous méprendre sur le fait qu'il s'agit d'une annonce concrète.
Il y a d'autres préoccupations dans le projet avec une plus grande pression de souffrance.</p>

<p><a name="per_tag"/></p>

<h2>Par nom ou par attribut</h2>

<p>L'application typique pour les surfaces dans l'API Overpass est,
télécharger tous les objets d'un même type ou tous les objets en général dans une même zone.
Nous commençons avec tous les objets d'un type modérément commun;
tous les objets en général sont trop de données,
pour s'entraîner avec des temps de réaction courts.
Lorsque le mécanisme des surfaces est introduit dans cette section,
le téléchargement de tous les objets de la <a href="area.html#full">section suivante</a> suit.</p>

<p>Tout d'abord, nous voulons afficher <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=30.0&amp;lon=0.0&amp;zoom=2&amp;Q=area%5Bname%3D%22London%22%5D%3B%0Anwr%5Bshop%3Dsupermarket%5D%28area%29%3B%0Aout%20center%3B">tous les supermarchés de Londres</a>:</p>

<pre>
<codeline>area[name="London"];</codeline>
<codeline>nwr[shop=supermarket](area);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Le travail proprement dit est effectué à la ligne 2:
là le <em>filtre</em> <code>(area)</code> restreint les objets à sélectionner
à un tel seulement dans les surfaces de l'ensemble <code>_</code>;
donc on a déjà dû apporter la surface à Londres.</p>

<p>La ligne 1 sélectionne tous les objets du type <em>area</em>,
qui ont un attribut avec la clé <code>name</code> et la valeur <code>London</code>.
Ce type d'objet est expliqué <a href="area.html#background">ci-dessous</a>.
C'est aussi une <a href="../preface/design.html#statements">instruction query</a> spéciale.</p>

<p>Étonnamment, les sites sont répartis sur la moitié de la planète.
Il y a de nombreux quartiers appelés <code>London</code>;
nous devons dire que nous sommes intéressés par le grand Londres en Angleterre.
Nous disposons de cinq solutions différentes,
pour clarifier notre demande.</p>

<p>Nous pouvons <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=30.0&amp;lon=0.0&amp;zoom=2&amp;Q=area%5Bname%3D%22London%22%5D%3B%0Anwr%5Bshop%3Dsupermarket%5D%28area%29%2850%2E5%2C%2D1%2C52%2E5%2C1%29%3B%0Aout%20center%3B">placer et utiliser</a> un grand rectangle englobant autour de la région cible approximative:</p>

<pre>
<codeline>area[name="London"];</codeline>
<codeline>nwr[shop=supermarket](area)(50.5,-1,52.5,1);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Pour votre commodité, veuillez noter que cela <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=10&amp;Q=area%5Bname%3D%22London%22%5D%3B%0Anwr%5Bshop%3Dsupermarket%5D%28area%29%28%7B%7Bbbox%7D%7D%29%3B%0Aout%20center%3B">fonctionne</a> également avec <a href="../targets/turbo.html#convenience">la fonction de confort</a> de <em>Overpass Turbo</em>:</p>

<pre>
<codeline>area[name="London"];</codeline>
<codeline>nwr[shop=supermarket](area)({{bbox}});</codeline>
<codeline>out center;</codeline>
</pre>

<p>Dans les deux cas, le rectangle englobant est un filtre parallèle à <code>(area)</code>.
Un rectangle englobant n'a jamais été implémentée pour la solution temporaire <em>area</em>,
et c'est aussi parce que c'est suffisant,
appliquer le filtre une instruction plus tard.</p>

<p>De même, nous pouvons profiter du fait que Londres est située au Royaume-Uni.
Une <a href="area.html#combining">section ultérieure</a> montre toutes les possibilités.</p>

<p>Enfin, vous pouvez utiliser d'autres attributs pour distinguer des surfaces avec le même attribut <em>name</em>.
Dans le cas de Londres <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=30.0&amp;lon=0.0&amp;zoom=2&amp;Q=area%5Bname%3D%22London%22%5D%5B%22wikipedia%22%3D%22en%3ALondon%22%5D%3B%0Anwr%5Bshop%3Dsupermarket%5D%28area%29%3B%0Aout%20center%3B">l'attribut</a> avec la clé <em>wikipedia</em> aide:</p>

<pre>
<codeline>area[name="London"]["wikipedia"="en:London"];</codeline>
<codeline>nwr[shop=supermarket](area);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Comme déjà le premier filtre par attribut <code>[name="London"]</code>
le second filtre <code>["wikipedia"="en:London"]</code> est également appliqué à l'instruction <em>area</em> de la ligne 1.
Il ne reste donc cette fois qu'un seul objet <em>area</em>,
où nous voulons vraiment chercher.</p>

<p>D'autres filtres fréquemment utilisés peuvent être <code>admin_level</code> avec ou sans valeur ou <code>type=boundary</code>.
Il aide à <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=10&amp;Q=area%5Bname%3D%22London%22%5D%3B%0Aout%3B">afficher</a> d'abord tous les objets <em>area</em> trouvés;
veuillez passer à la vue des données dans le coin supérieur droit après avoir exécuté <em>Données</em> :</p>

<pre>
<codeline>area[name="London"];</codeline>
<codeline>out;</codeline>
</pre>

<p>La ligne 2 affiche ce que la ligne 1 trouve.
Veuillez regarder les résultats pour voir quels <em>attributs</em> sélectionner la bonne zone.
En utilisant les filtres <em>pivot</em> dans une requête, vous pouvez aussi les <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=30.0&amp;lon=0.0&amp;zoom=2&amp;Q=area%5Bname%3D%22London%22%5D%3B%0Anwr%28pivot%29%3B%0Aout%20geom%3B">visualiser</a>:</p>

<pre>
<codeline>area[name="London"];</codeline>
<codeline>nwr(pivot);</codeline>
<codeline>out geom;</codeline>
</pre>

<p>La ligne 2 contient une instruction <em>query</em> régulière.
Le <em>filtre</em> <code>(pivot)</code> dans lui permet exactement ces objets,
qui sont les créateurs des surfaces dans son entrée.
C'est l'ensemble <code>_</code>;
il a été rempli à la ligne 1.</p>

<p>La cinquième possibilité est une caractéristique de confort de <a href="../targets/turbo.html">Overpass Turbo</a>,
pour laisser Nominatim <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=10&amp;Q=%7B%7BgeocodeArea%3ALondon%7D%7D%3B%0Anwr%5Bshop%3Dsupermarket%5D%28area%29%3B%0Aout%20center%3B">sélectionner</a>:</p>

<pre>
<codeline>{{geocodeArea:London}};</codeline>
<codeline>nwr[shop=supermarket](area);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Ainsi, l'expression <code>{{geocodeArea:London}}</code> déclenche,
que <em>Overpass Turbo</em> demande à <em>Nominatim</em> quel est l'objet le plus plausible pour <code>London</code>.
Utilisant l'identifiant retourné par Nominatim,
Overpass Turbo remplace l'expression par une instruction cherchant par identifiant après la zone correspondante,
ici par exemple <code>area(3600065606)</code>.</p>

<p><a name="full"/></p>

<h2>Véritablement tous</h2>

<p>Nous voulons maintenant télécharger vraiment toutes les données dans un lieu.
Cela fonctionne presque avec la requête que nous avons utilisée <a href="area.html#per_tag">pour nous entraîner</a>.
Mais nous devons changer l'outil:
pour une zone de la taille de Londres, 10 millions d'objets ou plus se rassemblent rapidement,
tandis que <em>Overpass Turbo</em> ralentit déjà le navigateur à partir d'environ 2000 objets à l'inutilité.</p>

<p>De plus, vous êtes mieux servi avec des extraits régionaux dans presque toutes les régions à l'intérieur des frontières officielles, des états aux villes.
Détails <a href="other_sources.html#regional">dans la section correspondante</a>.</p>

<p>Vous pouvez télécharger les données brutes directement sur votre ordinateur local pour traitement ultérieur :
Ceci est fait dans <em>Overpass Turbo</em> sous <em>Export</em> dans le coin supérieur gauche du lien <code>données brutes depuis l'API Overpass</code>.
Il est normal que rien ne se passe après le clic.
Le téléchargement de Londres peut prendre plusieurs minutes.</p>

<p>Vous pouvez également utiliser des outils de téléchargement comme <a target="_blank" rel="noopener" href="https://www.gnu.org/software/wget/">Wget</a> ou <a target="_blank" rel="noopener" href="https://curl.haxx.se/">Curl</a>.
Pour cela, enregistrez l'une des requêtes ci-dessus dans un fichier local, par exemple <code>london.ql</code>.</p>

<p>Vous pouvez ensuite effectuer des requêtes à partir de la ligne de commande en utilisant
<!-- NO_QL_LINK --></p>

<pre>
<codeline>wget -O london.osm.gz --header='Accept-Encoding: gzip, deflate' \</codeline>
<codeline>    --post-file=london.ql 'https://overpass-api.de/api/interpreter'</codeline>
</pre>

<p>resp.
<!-- NO_QL_LINK --></p>

<pre>
<codeline>curl -H'Accept-Encoding: gzip, deflate' -d@- \</codeline>
<codeline>    'https://overpass-api.de/api/interpreter' \</codeline>
<codeline>    &lt;london.ql &gt;london.osm.gz</codeline>
</pre>

<p>Bien entendu, les deux commandes peuvent également être écrites en une seule ligne sans barre oblique inversée.
Dans les deux cas, vous me rendez un grand service, ainsi qu'à vous-même et à tous les autres utilisateurs,
si vous définissez l'en-tête supplémentaire <code>Accept-Encoding : gzip, deflate</code>.
Cela permet au serveur de compresser les données,
qui réduit la quantité de données d'un facteur 7
et soulage les deux extrémités de la connexion.</p>

<p>Nous en arrivons maintenant à la requête proprement dite.
Puisqu'une source de grandes quantités de données avec des données complètes sont des relations spatialement étendues,
est disponible pour l'application finale <a href="osm_types.html">variantes adaptées</a>.
Nous nous limitons d'abord ici à une variante souvent adaptée:
<!-- NO_QL_LINK --></p>

<pre>
<codeline>area[name="London"]["wikipedia"="en:London"];</codeline>
<codeline>(</codeline>
<codeline>  nwr(area);</codeline>
<codeline>  node(w);</codeline>
<codeline>);</codeline>
<codeline>out;</codeline>
</pre>

<p>Alternativement, il existe une variante avec utilisation multiple du filtre <em>area</em>.
Ensuite, les zones sélectionnées en entrée doivent être <a href="../preface/design.html#sets">mises en cache</a> dans une <em>variable d'ensemble nommée</em>:
<!-- NO_QL_LINK --></p>

<pre>
<codeline>area[name="London"]["wikipedia"="en:London"]-&gt;.surface_de_recherche;</codeline>
<codeline>(</codeline>
<codeline>  node(area.surface_de_recherche);</codeline>
<codeline>  way(area.surface_de_recherche);</codeline>
<codeline>  node(w);</codeline>
<codeline>);</codeline>
<codeline>out;</codeline>
</pre>

<p>Dans la ligne 3, l'instruction de requête écrit son résultat dans la sélection standard.
Puisque la sélection <em>area</em> est encore nécessaire comme entrée à la ligne 4,
il doit être situé à un endroit autre que la sélection par défaut.</p>

<p><a name="combining"/></p>

<h2>Surface dans surface</h2>

<p>Nous reviendrons sur le problème
de sélectionner Londres comme surface en Grande-Bretagne.
Ceci n'est pas mis en œuvre,
mais il y a deux autres possibilités ici aussi.</p>

<p>Vous pouvez rechercher des objets qui se trouvent <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=8&amp;Q=area%5Bname%3D%22London%22%5D%2D%3E%2Epetit%3B%0Aarea%5Bname%3D%22England%22%5D%2D%3E%2Egrand%3B%0Anwr%5Bshop%3Dsupermarket%5D%28area%2Epetit%29%28area%2Egrand%29%3B%0Aout%20center%3B">à l'intersection de deux surfaces</a>:</p>

<pre>
<codeline>area[name="London"]-&gt;.petit;</codeline>
<codeline>area[name="England"]-&gt;.grand;</codeline>
<codeline>nwr[shop=supermarket](area.petit)(area.grand);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Le filtrage proprement dit a lieu dans l'instruction <em>query</em> de la ligne 3;
Seuls les objets qui remplissent les trois filtres sont autorisés:
Le filtre <code>[shop=supermarket]</code> n'autorise que les objets avec le tag correspondant.
Le filtre <code>(area.petit)</code> restreint cela aux objets,
qui se trouvent à l'intérieur d'une des surfaces de l'ensemble nommé <code>petit</code>.
Le filtre <code>(area.grand)</code> réduit encore ce résultat aux objets,
qui se trouvent dans l'une des surfaces de l'ensemble nommé <code>grand</code>.</p>

<p>Maintenant, nous devons juste nous en assurer,
qu'en <code>petit</code> et en <code>grand</code> les surfaces prévues y sont.
Ils font des instructions après le mot clé <em>area</em> dans les lignes 1 et 2,
qui stockent leur résultat chaque dans une variable nommée.</p>

<p>L'autre procédure utilise la connexion entre <em>area</em> et l'objet générateur,
mais cette fois dans la direction opposée au filtre <em>pivot</em>.
Nous <a target="_blank" rel="noopener" href="https://overpass-turbo.eu/?lat=51.5&amp;lon=-0.1&amp;zoom=8&amp;Q=area%5Bname%3D%22England%22%5D%3B%0Arel%5Bname%3D%22London%22%5D%28area%29%3B%0Amap%5Fto%5Farea%3B%0Anwr%5Bshop%3Dsupermarket%5D%28area%29%3B%0Aout%20center%3B">sélectionnons</a> l'objet créé de la petite zone:</p>

<pre>
<codeline>area[name="England"];</codeline>
<codeline>rel[name="London"](area);</codeline>
<codeline>map_to_area;</codeline>
<codeline>nwr[shop=supermarket](area);</codeline>
<codeline>out center;</codeline>
</pre>

<p>Dans la ligne 4, nous voulons avoir exactement la <em>surface</em> de Londres comme entrée pour le filtre <code>(area)</code>.
Dans la ligne 2, nous sélectionnons tous les <em>relations</em> avec le nom <em>London</em>
et situées dans une des surfaces,
qui trouve <code>(area)</code> dans l'ensemble défaut <code>_</code>.
Pour cela, nous avions sélectionné toutes les zones portant le nom <code>England</code> à la ligne 1.</p>

<p>Mais nous avons besoin de surfaces dans la ligne 4,
alors que le filtre <code>(area)</code> ne peut pas filtrer que les surfaces et nous avons sélectionné <em>relations</em>.
Ceci est fait par <code>map_to_area</code>:
il sélectionne les surfaces créées par les objets aux objets à partir de son entrée.</p>

<p><a name="background"/></p>

<h2>Contexte technique</h2>

<p>Déjà au début du projet Overpass en 2009, il devrait y avoir la possibilité, 
pour pouvoir utiliser un A-se-situer-dans-B géométrique.
Ce n'était que mal compatible avec l'exigence,
<a href="../preface/assertions.html#faithful">de répresenter fidèlement les données d'OpenStreetMap</a>: 
Les zones dans OpenStreetMap sont un concept mixte de géométrie et de attributs,
des efforts crédibles ont été déployés pour élaborer un propre type de données <em>area</em>, 
et les règles pour savoir exactement quand un objet OpenStreetMap est une surface étaient encore en mouvement à l'époque.
Enfin, on a eu l'impression que les surfaces pouvaient facilement être endommagées et qu'il fallait s'y attendre plus souvent.</p>

<p>Par conséquent, les <em>surfaces</em> de l'API Overpass constituent un type de données distinct. 
Le serveur les génère dans un processus cyclique en arrière-plan selon un <a target="_blank" rel="noopener" href="https://github.com/drolbr/Overpass-API/tree/master/src/rules">groupe des règles</a> séparé du code. 
Cela facilite la tâche des opérateurs potentiels de leurs propres instances, 
décider eux-mêmes des surfaces qu'ils veulent créer. 
Chaque <em>area</em> reprend les attributs de l'objet à partir duquel il a été créé. </p>

<p>Cela a des conséquences:</p>

<ul>
<li>Les surfaces ne sont disponibles que plusieurs heures après leurs objets de génération.
Par conséquent, les modifications apportées aux objets de génération ont également un effet différé.</li>
<li>Si un objet générateur ne produit plus de surface valide,
l'ancien objet <em>area</em> reste jusqu'à ce qu'une nouvelle surface valide puisse être créée.</li>
<li>Les surfaces ont leurs propres règles selon lesquelles leurs identifiants sont dispersés.</li>
<li>Seule une partie des filtres pour les objets OpenStreetMap est également disponible pour surfaces.</li>
</ul>

<p>Mais le grand avantage est que le point de recherche dans la surface fonctionne de manière efficace et fiable.</p>

<p>Comme inconvénient, il s'est avéré que parfois des objets de surface exigés n'existent pas:
Pendant ce temps, presque tous les objets dans OpenStreetMap qui ont une géométrie capable d'être une surface, également sont utilisé comme surface.
Toutefois, si, selon les règles à la base de les attributs, le processus en arrière-plan ne considère pas l'objet comme un surface,
il n'y a pas d'objet <em>area</em> correspondant.</p>

<p>Inversement, je n'ai pas rencontré un seul cas au cours des 10 dernières années,
qui a adapté sa régles des surfaces à ses besoins particuliers.
Il y a probablement eu plus de compromis à accepter moins de terres,
pour gagner du temps de calcul en arrière-plan.
Cela signifie que l'ensemble de règles est défini de facto de manière centralisée,
et cela le prive de la plupart de ses avantages.</p>

<p>C'est pourquoi j'ai l'intention de le faire maintenant,
exécute également les opérations de surface directement sur les objets OpenStreetMap.</p>

<!-- Traduit avec www.DeepL.com/Translator, partiellement redigé -->
<hr/>
<p>prochaine: <a href="other_sources.html">Alternatives</a></p>

</body>
</html>
